{"pages":[{"title":"About","text":"关于博主王志强（Wang Zhiqiang）服务端工程师。 技术栈以php、python、node为主，主要从事后端服务开发，对于分布式基础的软件架构很感兴趣。 本站所有内容均代表个人观点，与本人雇主及其他团体无关。 关于模版程序采用hexo进行内容管理，参考 https://hexo.io/zh-cn/ 模版采用hexo-theme-icarus渲染到页面进行观看，参考https://github.com/ppoffice/hexo-theme-icarus","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Hexo Hello World Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/01/hello-world/"},{"title":"css-居中布局解决方案","text":"css居中布局解决方案 指当前元素在父级元素容器中，水平方向是居中显示 方案一：inline-block + text-algin 属性配合使用优缺点： 兼容性好 text-algin属性具有继承性，导致子元素的文本也是居中显示 12345678910111213141516171819202122232425262728293031#parent{ width: 100%; height: 200px; background: #ccc; /* * text-aglign属性值 * - left(左对齐) * - center（居中） * - right（右对齐） * display属性值： * - block 块级元素 * - inline 内联元素 * - inline-block 行内块级元素（块级+内联） */ text-align:center;}#child{ width: 200px; height: 200px; background: red; display: inline-block;}/*在上面代码中child无论是块还是文本都会显示居中，如果想要文本左对齐，那么就需要*/#child{ text-align:left;}&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt;我是谁&lt;/div&gt;&lt;/div&gt; 方案二：table+margin 属性配合使用优：只需要对子元素进行设置可以实现水平居中布局 缺：子元素脱离文档流，导致margin属性值无效 123456789101112131415161718192021222324&lt;style&gt;#parent{ width: 100%; height: 300px; background:aquamarine;} #child{ width: 300px; height: 300px; background:red; /** * margin属性:外边距 * - 一个值： 上右下左 * - 两个值： 上下，左右 * - 三个值： 上，左右，下 * - 四个值： 上，右，左，下 */ display:table; margin: 0 auto;}&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt;我是谁&lt;/div&gt;&lt;/div&gt; 方案三：absolute+ transform 属性配合使用优缺点 优：父级元素是否脱离文档流，不影响子级元素水平居中 缺：transform属性css3中新增的属性，浏览器支持不友好 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt;#parent{ width: 100%; height: 200px; background: #ccc; /* * 开启定位 * absolute 绝对定位 * fixed 相对固定定位 * relative 相对定位 * */ position: relative;}#child{ width: 200px; height: 200px; background: red; /* * 当前元素设置绝对定位之后: * 若父级没有开启定位，当前元素相当于页面定位 * 若父级开启定位的话，当前元素相当于当前父类进行定位 * * */ position: absolute; left: 50%; /* * 水平方向平移 （向左移动） * 移动的大小是根据当前元素的宽度来决定 */ transform: translateX(-50%);}&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt;我是谁&lt;/div&gt;&lt;/div&gt;","link":"/2020/06/09/html/css-centerlayout/"},{"title":"vue3.x 新特性","text":"本文主要围绕 vue-compisition-api，来讲解大家最关心的、同时也是 vue 3.0 最重要的一些新特性，例如 setup() 函数、reactive()、ref() 等这些 Vue Hooks。 基础要求 了解常见的 ES6 新特性 ES6 的导入导出语法 解构赋值 箭头函数 etc… 了解 vue 2.x 的基本使用 组件 常用的指令 生命周期函数 computed、watch、ref 等 相关资源 【知乎 - Vue Function-based API RFC】https://zhuanlan.zhihu.com/p/68477600 【github - vuejs/composition-api】https://github.com/vuejs/composition-api 【github - composition-api/CHANGELOG.md】https://github.com/vuejs/composition-api/blob/master/CHANGELOG.md 【开源中国 - 尤雨溪公布 Vue 3.0 开发路线：将从头开始重写 3.0】https://www.oschina.net/news/100515/plans-for-the-next-iteration-of-vue-js 初始化项目 安装 vue-cli3 123npm install -g @vue/cli# ORyarn global add @vue/cli 创建项目 123vue create my-project# ORvue ui 在项目中安装 composition-api 体验 vue3 新特性 123npm install @vue/composition-api --save# ORyarn add @vue/composition-api 在使用任何 @vue/composition-api 提供的能力前，必须先通过 Vue.use() 进行安装 1234import Vue from 'vue'import VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionApi) 安装插件后，您就可以使用新的 Composition API 来开发组件了。 setupsetup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口。 执行时机setup 函数会在 beforeCreate 之后、created 之前执行 接收 props 数据 在 props 中定义当前组件允许外界传递过来的参数名称： 123props: { p1: String} 通过 setup 函数的第一个形参，接收 props 数据： 123setup(props) { console.log(props.p1)} contextsetup 函数的第二个形参是一个上下文对象，这个上下文对象中包含了一些有用的属性，这些属性在 vue 2.x 中需要通过 this 才能访问到，在 vue 3.x 中，它们的访问方式如下： 12345678910const MyComponent = { setup(props, context) { context.attrs context.slots context.parent context.root context.emit context.refs }} 注意：在 setup() 函数中无法访问到 this reactivereactive() 函数接收一个普通对象，返回一个响应式的数据对象。 基本语法等价于 vue 2.x 中的 Vue.observable() 函数，vue 3.x 中提供了 reactive() 函数，用来创建响应式的数据对象，基本代码示例如下： 1234import { reactive } from '@vue/composition-api'// 创建响应式数据对象，得到的 state 类似于 vue 2.x 中 data() 返回的响应式对象const state = reactive({ count: 0 }) 定义响应式数据供 template 使用 按需导入 reactive 函数： 1import { reactive } from '@vue/composition-api' 在 setup() 函数中调用 reactive() 函数，创建响应式数据对象： 1234567setup() { // 创建响应式数据对象 const state = reactive({count: 0}) // setup 函数中将响应式数据对象 return 出去，供 template 使用 return state} 在 template 中访问响应式数据： 1&lt;p&gt;当前的 count 值为：{{count}}&lt;/p&gt; ref基本语法ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性： 1234567891011import { ref } from '@vue/composition-api'// 创建响应式数据对象 count，初始值为 0const count = ref(0)// 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以console.log(count.value) // 输出 0// 让 count 的值 +1count.value++// 再次打印 count 的值console.log(count.value) // 输出 1 在 template 中访问 ref 创建的响应式数据 在 setup() 中创建响应式数据： 12345678910import { ref } from '@vue/composition-api'setup() { const count = ref(0) return { count, name: ref('zs') }} 在 template 中访问响应式数据： 123&lt;template&gt; &lt;p&gt;{{count}} --- {{name}}&lt;/p&gt;&lt;/template&gt; 在 reactive 对象中访问 ref 创建的响应式数据当把 ref() 创建出来的响应式数据对象，挂载到 reactive() 上时，会自动把响应式数据对象展开为原始的值，不需通过 .value 就可以直接被访问，例如： 12345678const count = ref(0)const state = reactive({ count})console.log(state.count) // 输出 0state.count++ // 此处不需要通过 .value 就能直接访问原始值console.log(count) // 输出 1 注意：新的 ref 会覆盖旧的 ref，示例代码如下： 123456789101112131415// 创建 ref 并挂载到 reactive 中const c1 = ref(0)const state = reactive({ c1})// 再次创建 ref，命名为 c2const c2 = ref(9)// 将 旧 ref c1 替换为 新 ref c2state.c1 = c2state.c1++console.log(state.c1) // 输出 10console.log(c2.value) // 输出 10console.log(c1.value) // 输出 0 isRefisRef() 用来判断某个值是否为 ref() 创建出来的对象；应用场景：当需要展开某个可能为 ref() 创建出来的值的时候，例如： 123import { isRef } from '@vue/composition-api'const unwrapped = isRef(foo) ? foo.value : foo toRefstoRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据，最常见的应用场景如下： 12345678910111213141516171819202122import { toRefs } from '@vue/composition-api'setup() { // 定义响应式数据对象 const state = reactive({ count: 0 }) // 定义页面上可用的事件处理函数 const increment = () =&gt; { state.count++ } // 在 setup 中返回一个对象供页面使用 // 这个对象中可以包含响应式的数据，也可以包含事件处理函数 return { // 将 state 上的每个属性，都转化为 ref 形式的响应式数据 ...toRefs(state), // 自增的事件处理函数 increment }} 页面上可以直接访问 setup() 中 return 出来的响应式数据： 123456&lt;template&gt; &lt;div&gt; &lt;p&gt;当前的count值为：{{count}}&lt;/p&gt; &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; computedcomputed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入： 1import { computed } from '@vue/composition-api' 创建只读的计算属性在调用 computed() 函数期间，传入一个 function 函数，可以得到一个只读的计算属性，示例代码如下： 123456789// 创建一个 ref 响应式数据const count = ref(1)// 根据 count 的值，创建一个响应式的计算属性 plusOne// 它会根据依赖的 ref 自动计算并返回一个新的 refconst plusOne = computed(() =&gt; count.value + 1)console.log(plusOne.value) // 输出 2plusOne.value++ // error 创建可读可写的计算属性在调用 computed() 函数期间，传入一个包含 get 和 set 函数的对象，可以得到一个可读可写的计算属性，示例代码如下： 1234567891011121314151617// 创建一个 ref 响应式数据const count = ref(1)// 创建一个 computed 计算属性const plusOne = computed({ // 取值函数 get: () =&gt; count.value + 1, // 赋值函数 set: val =&gt; { count.value = val - 1 }})// 为计算属性赋值的操作，会触发 set 函数plusOne.value = 9// 触发 set 函数后，count 的值会被更新console.log(count.value) // 输出 8 watchwatch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入： 1import { watch } from '@vue/composition-api' 基本用法1234567891011const count = ref(0)// 定义 watch，只要 count 值变化，就会触发 watch 回调// watch 会在创建时会自动调用一次watch(() =&gt; console.log(count.value))// 输出 0setTimeout(() =&gt; { count.value++ // 输出 1}, 1000) 监视指定的数据源监视 reactive 类型的数据源： 123456789// 定义数据源const state = reactive({ count: 0 })// 监视 state.count 这个数据节点的变化watch( () =&gt; state.count, (count, prevCount) =&gt; { /* ... */ }) 监视 ref 类型的数据源： 123456// 定义数据源const count = ref(0)// 指定要监视的数据源watch(count, (count, prevCount) =&gt; { /* ... */}) 监视多个数据源监视 reactive 类型的数据源： 1234567891011121314151617181920const state = reactive({ count: 0, name: 'zs' })watch( [() =&gt; state.count, () =&gt; state.name], // Object.values(toRefs(state)), ([count, name], [prevCount, prevName]) =&gt; { console.log(count) // 新的 count 值 console.log(name) // 新的 name 值 console.log('------------') console.log(prevCount) // 旧的 count 值 console.log(prevName) // 新的 name 值 }, { lazy: true // 在 watch 被创建的时候，不执行回调函数中的代码 })setTimeout(() =&gt; { state.count++ state.name = 'ls'}, 1000) 监视 ref 类型的数据源： 123456789101112131415161718192021const count = ref(0)const name = ref('zs')watch( [count, name], // 需要被监视的多个 ref 数据源 ([count, name], [prevCount, prevName]) =&gt; { console.log(count) console.log(name) console.log('-------------') console.log(prevCount) console.log(prevName) }, { lazy: true })setTimeout(() =&gt; { count.value++ name.value = 'xiaomaolv'}, 1000) 清除监视在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下： 1234567// 创建监视，并得到 停止函数const stop = watch(() =&gt; { /* ... */})// 调用停止函数，清除对应的监视stop() 在 watch 中清除无效的异步任务有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用： watch 被重复执行了 watch 被强制 stop 了 Template 中的代码示例如下： 1/* template 中的代码 */ &lt;input type=&quot;text&quot; v-model=&quot;keywords&quot; /&gt; Script 中的代码示例如下： 1234567891011121314151617181920212223242526272829// 定义响应式数据 keywordsconst keywords = ref('')// 异步任务：打印用户输入的关键词const asyncPrint = val =&gt; { // 延时 1 秒后打印 return setTimeout(() =&gt; { console.log(val) }, 1000)}// 定义 watch 监听watch( keywords, (keywords, prevKeywords, onCleanup) =&gt; { // 执行异步任务，并得到关闭异步任务的 timerId const timerId = asyncPrint(keywords) // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务 onCleanup(() =&gt; clearTimeout(timerId)) }, // watch 刚被创建的时候不执行 { lazy: true })// 把 template 中需要的数据 return 出去return { keywords} LifeCycle Hooks新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下： 123456789101112131415import { onMounted, onUpdated, onUnmounted } from '@vue/composition-api'const MyComponent = { setup() { onMounted(() =&gt; { console.log('mounted!') }) onUpdated(() =&gt; { console.log('updated!') }) onUnmounted(() =&gt; { console.log('unmounted!') }) }} 下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系： beforeCreate -&gt; use setup() created -&gt; use setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured provide &amp; injectprovide() 和 inject() 可以实现嵌套组件之间的数据传递。这两个函数只能在 setup() 函数中使用。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据。 共享普通数据App.vue 根组件： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;App 根组件&lt;/h1&gt; &lt;hr /&gt; &lt;LevelOne /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import LevelOne from './components/LevelOne'// 1. 按需导入 provideimport { provide } from '@vue/composition-api'export default { name: 'app', setup() { // 2. App 根组件作为父级组件，通过 provide 函数向子级组件共享数据（不限层级） // provide('要共享的数据名称', 被共享的数据) provide('globalColor', 'red') }, components: { LevelOne }}&lt;/script&gt; LevelOne.vue 组件： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;!-- 4. 通过属性绑定，为标签设置字体颜色 --&gt; &lt;h3 :style=&quot;{color: themeColor}&quot;&gt;Level One&lt;/h3&gt; &lt;hr /&gt; &lt;LevelTwo /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import LevelTwo from './LevelTwo'// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default { setup() { // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const themeColor = inject('globalColor') // 3. 把接收到的共享数据 return 给 Template 使用 return { themeColor } }, components: { LevelTwo }}&lt;/script&gt; LevelTwo.vue 组件： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;!-- 4. 通过属性绑定，为标签设置字体颜色 --&gt; &lt;h5 :style=&quot;{color: themeColor}&quot;&gt;Level Two&lt;/h5&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default { setup() { // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const themeColor = inject('globalColor') // 3. 把接收到的共享数据 return 给 Template 使用 return { themeColor } }}&lt;/script&gt; 共享 ref 响应式数据如下代码实现了点按钮切换主题颜色的功能，主要修改了 App.vue 组件中的代码，LevelOne.vue 和 LevelTwo.vue 中的代码不受任何改变： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;App 根组件&lt;/h1&gt; &lt;!-- 点击 App.vue 中的按钮，切换子组件中文字的颜色 --&gt; &lt;button @click=&quot;themeColor='red'&quot;&gt;红色&lt;/button&gt; &lt;button @click=&quot;themeColor='blue'&quot;&gt;蓝色&lt;/button&gt; &lt;button @click=&quot;themeColor='orange'&quot;&gt;橘黄色&lt;/button&gt; &lt;hr /&gt; &lt;LevelOne /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import LevelOne from './components/LevelOne'import { provide, ref } from '@vue/composition-api'export default { name: 'app', setup() { // 定义 ref 响应式数据 const themeColor = ref('red') // 把 ref 数据通过 provide 提供的子组件使用 provide('globalColor', themeColor) // setup 中 return 数据供当前组件的 Template 使用 return { themeColor } }, components: { LevelOne }}&lt;/script&gt; template refs通过 ref() 还可以引用页面上的元素或组件。 元素的引用示例代码如下： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;h3 ref=&quot;h3Ref&quot;&gt;TemplateRefOne&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { ref, onMounted } from '@vue/composition-api'export default { setup() { // 创建一个 DOM 引用 const h3Ref = ref(null) // 在 DOM 首次加载完毕之后，才能获取到元素的引用 onMounted(() =&gt; { // 为 dom 元素设置字体颜色 // h3Ref.value 是原生DOM对象 h3Ref.value.style.color = 'red' }) // 把创建的引用 return 出去 return { h3Ref } }}&lt;/script&gt; 组件的引用TemplateRefOne.vue 中的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;h3&gt;TemplateRefOne&lt;/h3&gt; &lt;!-- 4. 点击按钮展示子组件的 count 值 --&gt; &lt;button @click=&quot;showNumber&quot;&gt;获取TemplateRefTwo中的count值&lt;/button&gt; &lt;hr /&gt; &lt;!-- 3. 为组件添加 ref 引用 --&gt; &lt;TemplateRefTwo ref=&quot;comRef&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { ref } from '@vue/composition-api'import TemplateRefTwo from './TemplateRefTwo'export default { setup() { // 1. 创建一个组件的 ref 引用 const comRef = ref(null) // 5. 展示子组件中 count 的值 const showNumber = () =&gt; { console.log(comRef.value.count) } // 2. 把创建的引用 return 出去 return { comRef, showNumber } }, components: { TemplateRefTwo }}&lt;/script&gt; TemplateRefTwo.vue 中的示例代码： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;h5&gt;TemplateRefTwo --- {{count}}&lt;/h5&gt; &lt;!-- 3. 点击按钮，让 count 值自增 +1 --&gt; &lt;button @click=\"count+=1\"&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { ref } from '@vue/composition-api'export default { setup() { // 1. 定义响应式的数据 const count = ref(0) // 2. 把响应式数据 return 给 Template 使用 return { count } }}&lt;/script&gt; createComponent 这个函数不是必须的，除非你想要完美结合 TypeScript 提供的类型推断来进行项目的开发。 这个函数仅仅提供了类型推断，方便在结合 TypeScript 书写代码时，能为 setup() 中的 props 提供完整的类型推断。 12345678910import { createComponent } from 'vue'export default createComponent({ props: { foo: String }, setup(props) { props.foo // &lt;- type: string }})","link":"/2020/06/18/html/vue3-newfeatures/"},{"title":"docker环境下solr使用记录","text":"solr环境运行 导入mysql数据 安装solr并创建core下载指定solr版本https://hub.docker.com/_/solr?tab=tags 1docker pull solr:6.6.6 运行1docker run --name solr -p 8983:8983 -d solr 创建 solr 的 core访问 http://localhost:8983/solr/#/~cores/new_core 点击 Add Core，输入name,instanceDir，这时候会弹出 1Error CREATEing SolrCore 'new_core': Unable to create core [new_core] Caused by: Can't find resource 'solrconfig.xml' in classpath or '/opt/solr/server/solr/new_core' 解决方案：将默认的配置信息拷贝到new_core目录下 12docker exec -d solr mkdir -p /opt/solr/server/solr/new_coredocker exec -d solr cp -r /opt/solr/server/solr/configsets/sample_techproducts_configs/conf/ /opt/solr/server/solr/new_core 重启镜像1docker restart solr mysql数据导入到solr中准备条件123docker exec -d solr wget -P /opt/solr/server/solr-webapp/webapp/WEB-INF/lib https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.9/mysql-connector-java-5.1.9.jardocker exec -d solr cp /opt/solr/dist/solr-dataimporthandler-6.6.6.jar /opt/solr/server/solr-webapp/webapp/WEB-INF/lib 修改配置文件12docker cp solr:/opt/solr/server/solr/new_core/conf/solrconfig.xml .vim solrconfig.xml 在/opt/solr/server/solr/new_core/solrconfig.xml 的&lt;config&gt;&lt;/config&gt;标签里添加下面内容 12345&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt; &lt;lst name=&quot;defaults&quot;&gt; &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 添加完成之后 1docker cp solrconfig.xml solr:/opt/solr/server/solr/new_core/conf/solrconfig.xml 在同一个目录下面新建一个 data-config.xml 并写入下面内容，这里 column 是指数据库中的列明，name 是指solr中显示的名称 123456789&lt;dataConfig&gt; &lt;dataSource name=&quot;user&quot; type=&quot;JdbcDataSource&quot; driver=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/hexo&quot; user=&quot;root&quot; password=&quot;123456&quot;/&gt; &lt;document&gt; &lt;entity name=&quot;user&quot; query=&quot;select * from user&quot; dataSource=&quot;source&quot; &gt; &lt;field column=&quot;db_name&quot; name=&quot;name&quot; /&gt; &lt;field column=&quot;db_password&quot; name=&quot;password&quot; /&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; 我是在宿主进行编辑需要拷贝到容器中 1docker cp data-config.xml solr:/opt/solr/server/solr/new_core/conf/ mysql同步最后一步访问 http://localhost:8983/solr/#/new_core/schema点击 Add Field:在 db_name输入db_name 在field type选择string,在 db_name输入db_password 在field type选择string 数据点击同步访问http://localhost:8983/solr/#/new_core/dataimport//dataimport执行 Execute","link":"/2020/11/22/docker/solr/"},{"title":"css-垂直居中布局解决方案","text":"css 垂直居中布局解决方案 指当前元素在父级元素容器中，垂直方向居中显示 方案一：table-cell + vertical-algin 属性配合使用 1234567891011121314151617&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;居中文字&lt;/div&gt;&lt;/div&gt;&lt;style&gt; /* table 设置table元素 table-cell 设置元素td元素 */ display: table-cell; /* * vertical-align属性 用于设置文本内容垂直方向对齐方式 * top 顶部对齐 * middle 居中对齐 * bottom 底部对齐 */ vertical-align: middle;&lt;/style&gt; 方案二：absolute + transfrom属性配合使用 12345678.parent { position: relative;}.child { position: absolute; top: 50%; transform: translateY(-50%);}","link":"/2020/06/09/html/css-verticalcenterlayout/"},{"title":"mysql分表","text":"分表常见方法 mysql实战分表 《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。 分表的方法 中间件方式。如 mysql cluster ，mysql proxy，mysql replication，drdb等等 业务逻辑去分，如果订单按照日期，订单一个用户一张订单表，hash方式等等 merge存储引擎来实现分表 分表实战接下来是结合业务逻辑和merge去实现分表实战 code_1表创建插入数据 123456CREATE TABLE `mm_1` ( `full_code` CHAR (10) NOT NULL, PRIMARY KEY (`full_code`))ENGINE=MyISAM DEFAULT CHARACTER SET=utf8;INSERT INTO mm_1 VALUES (1), (2), (3); code_2表创建插入数据 1234567CREATE TABLE `mm_2` ( `full_code` CHAR (10) NOT NULL, PRIMARY KEY (`full_code`))ENGINE=MyISAM DEFAULT CHARACTER SET=utf8;INSERT INTO mm_2 VALUES (4), (5), (6); 使用merge创建合表数据 1234create table if not exists mm( `full_code` CHAR (10) NOT NULL, index(full_code))engine = merge union=(mm_1,mm_2) insert_method = last auto_increment=1 default charset=utf8;","link":"/2020/08/01/database/mysql-sub-table/"},{"title":"冷热分离","text":"什么是冷热分离 什么情况下使用冷热分离 实现思路 如何触发冷热分离以及优缺点 如何实现 如何使用 什么是冷热分离就是数据分成冷库和热库2个库，冷库只存放那那些走到终态的数据，热库存放还需要去修改字段的数据 什么情况下使用冷热分离 数据走到终态后，对数据只有读的没有写的需求，比如订单完结状态 用户能接受新旧数据分开查询，比如订单列表默认只能查询三个月内的订单，如果查询更早的状态，需要切换页面进行查询 实现思路如果判断数据到底是冷数据还是热数据 时间维度：在我们订单主表中一定会记录该订单的下单时间，我们可以将三个月之前的作为冷数据，三个月之内的数据作为热数据 状态维度：我们可以将已完结的订单作为冷数据，其他作为热数据 在实际工作中，我们可以根据下单时间和订单状态进行分离 如何触发冷热分离以及优缺点 修改写操作业务逻辑 监听数据库变binlog更日志 定时扫描数据库 优点 代码灵活可控 ；保证数据实时性 与业务代码解耦；可以做到低延时 与代码解耦；可以根据时间区分冷热数据的场景 缺点 不能按照时间区分冷热，当数据变成冷数据，期间可能没有其他任何操作；需要修改㕛数据库的写操作的代码 不能按照时间区分冷热，当数据变成冷数据，期间可能没有其他任何操作；需要考虑数据并发操作，就是业务代码与冷热变更代码同时操作同一个数据 不能做到实时 根据实际场景选择一个最优的方案，个人比较采用定时扫描的方案。 如何实现 1）在热数据中，给要搬的数据添加一个标识 2）找出待搬的数据，进行标记 3）使用事务进行包裹，将冷的数据保存在冷库中 4）删除原数据冷数据部分 在实现的过程中，会遇到各种各样的问题都是值得我们深思熟虑 1.同时修改多个数据库，如何保证数据的一致性？ 2.假设数据量大，一次性处理不完，该怎么办？是否需要使用批量处理？ 3.假设数据量大到要分到多个地方并行处理，该怎么办？ 如何使用 一般都会有一个选项供我们选择需要查询冷数据还是热数据，如果界面上没有提供，我们可以直接在业务代码里区分。","link":"/2020/12/29/database/cold-and-hot/"},{"title":"Mysql设计与开发规范","text":"数据库设计 sql编写 本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障 设计规范 以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低 对于不满足【高危】和【强制】两个级别的设计，DBA有权利强制打回要求修改 库名1.【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量体现join的关系，如user表和user_login表 2.【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的库名尽量使用统一前缀 3.【强制】一般分库名称命名格式是库通配名_编号，编号从0开始递增，比如wenda_001以时间进行分库的名称格式是“库通配名_时间” 4.【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：create database db1 default character set utf8; 表结构1.【强制】表必须有主键，且设置id为自增主键 2.【强制】表禁止使用外键，如果要保证完整下，应由程序端实现，外键使表之间相互耦合，影响update、delete等性能，有可能造成死锁，高并发环境下容易导致数据库性能瓶颈 3.【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。如表名过长可以采用缩写等方式 4.【强制】创建表时必须显式指定字符集为utf8或utf8mb4 5.【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB/MyISAM/Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB 6.【强制】建表必须有comment，表级别和字段级别都要有comment 7.【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint（为了以后延展性，这里要求新建表统一为bigint），且为auto_increment(2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降 8.【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段create_time和最后更新时间字段update_time，便于查问题 9.【建议】表中所有字段必须都是NOT NULL default 默认值 属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差以及索引失效等问题 10.【建议】建议对表里的blob、text等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select 11.【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如user_name属性在user_account，user_login_log等表里冗余一份，减少join查询 12.【强制】中间表用于保留中间结果集，名称必须以tmp_开头。备份表用于备份或抓取源表快照，名称必须以bak_开头。中间表和备份表定期清理 13.【强制】对于线上执行DDL变更，必须经过DBA审核，并由DBA在业务低峰期执行 列数据类型优化1.【建议】表中的自增列（auto_increment属性），推荐使用bigint类型。因为无符号int存储范围为-2147483648~2147483647（大约21亿左右），溢出后会导致报错 2.【建议】业务中选择性很少的状态status、类型type等字段推荐使用tinytint或者smallint类型节省存储空 3.【建议】业务中IP地址字段推荐使用int类型，不推荐用char(15)。因为int只占4字节，可以用如下函数相互转换，而char(15)占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。 SQL：select inet_aton(‘192.168.2.12’); select inet_ntoa(3232236044); PHP: ip2long(‘192.168.2.12’); long2ip(3530427185); 4.【建议】不推荐使用enum，set。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用tinyint或smallint 5.【建议】不推荐使用blob，text等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段 6.【建议】存储金钱的字段，建议用int，程序端乘以100和除以100进行存取。或者用decimal类型，而不要用double 7.【建议】文本数据尽量用varchar存储。因为varchar是变长存储，比char更省空间。MySQL server层规定一行所有文本最多存65535字节 8.【建议】时间类型尽量选取datetime。而timestamp虽然占用空间少，但是有时间范围为1970-01-01 00:00:01到2038-01-01 00:00:00的问题 索引设计1.【强制】InnoDB表必须主键为id int/bigint auto_increment,且主键值禁止被更新 2.【建议】唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，一律使用小写格式，以字段的名称或缩写作为后缀 3.【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引 4.【强制】单个索引中每个索引记录的长度不能超过64KB 5.【建议】单个表上的索引个数不能超过5个 6.【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列userid的区分度可由select count(distinct userid)计算出来 7.【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高 8.【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除 分库分表、分区表1.【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列 2.【强制】单个分区表中的分区（包括子分区）个数不能超过1024 3.【强制】上线前RD或者DBA必须指定分区表的创建、清理策略 4.【强制】访问分区表的SQL必须包含分区键 5.【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个 6.【强制】对于分区表执行alter table操作，必须在业务低峰期执行 7.【强制】采用分库策略的，库的数量不能超过1024 8.【强制】采用分表策略的，表的数量不能超过4096 9.【建议】单个分表建议不超过500W行，这样才能保证数据查询性能更佳 10.【建议】水平分表尽量用取模方式，并预留出足够的buffer，以免日后需要重新拆分和迁移，日志、报表类数据建议采用日期进行分表 字符集1.【强制】数据库本身库、表、列所有字符集必须保持一致，为utf8或utf8mb4 2.【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为utf8 SQL编写DML语句1.【强制】SELECT语句必须指定具体字段名称，禁止写成*。因为select *会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但程序端没有来得及更新的话，系统会报错 2.【强制】insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上 3.【建议】insert into…values(XX),(XX),(XX)…。这里XX的值不要超过500个。值过多虽然上线很很快，但会引起主从同步延迟 4.【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在3个以内。因为union all不需要去重，节省数据库资源，提高性能 5.【建议】in值列表限制在500以内。例如select… where userid in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询 6.【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次 7.【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步中断 8.【强制】写入和事务发往主库，只读SQL发往从库，即程序端实现读写分离 9.【强制】DML语句必须有where条件，且使用索引查找 10.【强制】生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等。因为hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，我们要尽量让MySQL优化器自己选择执行计划 11.【强制】where条件里等号左右字段类型必须一致，否则无法利用索引 12.【建议】SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找 13.【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引 14.【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，如果要使用like，请使用like ‘xxxx%’的方式，必须有其他等值或范围查询条件，否则无法利用索引 15.【建议】索引列不要使用函数或表达式，否则无法利用索引。如where length(name)=’Admin’或where user_id+2=10023 16.【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b) 17.【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select a,b,c from t1 limit 10000,20;优化为: select a,b,c from t1 where id&gt;10000 limit 20; 多表连接1.【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础 2.【强制】禁止在业务的更新类SQL语句中使用join，比如update t1 join t2… 3.【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询 4.【建议】线上环境，多表join不要超过3个表 5.【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如select a from db1.table1 alias1 where … 6.【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表 事务1.【建议】事务中INSERT|UPDATE|DELETE|REPLACE语句操作的行数控制在1000以内，以及WHERE子句中IN列表的传参个数控制在500以内 2.【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值1-2秒 3.【建议】对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内 4.【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为repeatable-read 5.【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题 6.【建议】事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁 7.【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长 8.【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库 排序和分组1.【建议】减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的 2.【建议】order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b) 3.【建议】包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢 线上禁止使用的SQL语句1.【高危】禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。如果是非row格式的binlog格式，会导致主从不一致，导致数据错乱。建议加上order by PK 2.【高危】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下 3.【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现 4.【建议】禁用insert into …on duplicate key update…、replace into等语句，在高并发环境下，极容易导致死锁 5.【强制】禁止联表更新语句，如update t1,t2 where t1.id=t2.id…","link":"/2020/07/29/database/mysql-dev-specification/"},{"title":"docker环境下gitlab使用记录","text":"docker运行gitlab 配置ssl 数据备份 数据还原 汉化 docker安装运行gitlab12345678910mkdir -p /data/gitlab/etc /data/gitlab/logs /data/gitlab/datadocker run --name gitlab \\-p 8022:22 -p 8443:443 -p 8080:80 \\--memory 4g \\--restart always \\-v /data/gitlab/etc:/etc/gitlab \\-v /data/gitlab/logs:/var/log/gitlab \\-v /data/gitlab/data:/var/opt/gitlab \\-d gitlab/gitlab-ce:12.3.5-ce.0 –name 命令容器的名称 -d 报错容器后台持续运行 -p 暴露端口 -v 挂在目录 配置 GitLab 使用 HTTPS 协议挂在在容器中配置https修改配置文件vim /data/gitlab/etc/gitlab.rb 123456789101112131415161718192021222324252627#################################################### 添加外部请求的域名(如果不支持https, 可以改成http)external_url 'https://gitlab.example.com'# 修改gitlab对应的时区 gitlab_rails['time_zone'] = 'PRC'# 开启邮件支持 gitlab_rails['gitlab_email_enabled'] = truegitlab_rails['gitlab_email_from'] = 'gitlab@example.com'gitlab_rails['gitlab_email_display_name'] = 'GitLab'# 配置邮件参数gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = &quot;smtp.163.com&quot;gitlab_rails['smtp_port'] = 25gitlab_rails['smtp_user_name'] = &quot;gitlab@example.com&quot;gitlab_rails['smtp_password'] = &quot;xxxxxx&quot;gitlab_rails['smtp_domain'] = &quot;domian.com&quot;gitlab_rails['smtp_authentication'] = &quot;login&quot;gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = false ####################################################SSL密钥相关配置#nginx['redirect_http_to_https'] = truenginx['ssl_certificate'] = &quot;/data/gitlab/ssl/gitlab.example.com.crt&quot;nginx['ssl_certificate_key'] = &quot;/data/gitlab/ssl/gitlab.example.com.key&quot; 配置https主要修改参数 123456# 域名(https://)external_url 'https://gitlab.example.com'# http重定向到httpsnginx['redirect_http_to_https'] = truenginx['ssl_certificate'] = &quot;/data/gitlab/ssl/gitlab.example.com.crt&quot;nginx['ssl_certificate_key'] = &quot;/data/gitlab/ssl/gitlab.example.com.key&quot; 修改配置文件就需要进行重启 123gitlab-ctl reconfiguredocker restart gitlab 挂在在宿主nginx上配置https配置文件修改 12345678# 禁用`gitlab`内置的`nginx`nginx['enable'] = false# 修改成与`nginx`运行时的用户一致web_server['external_users'] = ['root']# 监听方式为 tcpgitlab_workhorse['listen_network'] = &quot;tcp&quot;# 下面的192.168.1.24为本机IP，根据实际情况修改，不能为 localhost 或者 127.0.0.1，否则 docker 访问不到，8181是默认监听的端口gitlab_workhorse['listen_addr'] = &quot;192.168.1.24:8181&quot; 修改完配置重启容器 123docker exec gitlab gitlab-ctl reconfiguregitlab-ctl reconfiguredocker restart gitlab 宿主nginx 配置文件gitlab.conf 参考：https://gitlab.com/gitlab-org/gitlab-recipes/tree/master/web-server/nginx 需要修改地方 1234upstream gitlab-workhorse { server unix:/data/gitlab/data/gitlab-workhorse/socket fail_timeout=0;}server_name gitlab.example.com; 数据备份1docker exec -t gitlab gitlab-rake gitlab:backup:create 命令执行成功后会在 gitlab 容器目录 /var/opt/gitlab/backups 生产文件 数据恢复 确定gitlab版本是否一致 确保将备份备份文件放在 /var/opt/gitlab/backups目录下 12345678910# 停止相关数据连接服务gitlab-ctl stop unicorngitlab-ctl stop sidekiq# 验证是全部停止gitlab-ctl status#恢复数据gitlab-rake gitlab:backup:restore BACKUP=1549850985_2019_02_11_11.4.5# 启动Gitlabgitlab-ctl start 汉化 https://gitlab.com/xhang/gitlab 确定版本之后在进行操作 1234567891011# 确定安装的版本cat /opt/gitlab/embedded/service/gitlab-rails/VERSION# 下载汉化包wget https://gitlab.com/xhang/gitlab/-/archive/v12.3.5-zh/gitlab-v12.3.5-zh.tar.gz# 解压汉化包tar -xvf gitlab-v12.3.5-zh.tar.gz# 将汉化文件覆盖掉原文件cp -rf gitlab-v12.3.5-zh/* /opt/gitlab/embedded/service/gitlab-rails/# Docker安装需要清理临时的一些文rm -rf /opt/gitlab/embedded/nodes/*","link":"/2020/11/22/docker/gitlab/"},{"title":"mysql索引类型","text":"mysql索引类型 1 普通索引最基本的缩影，他没有任何限制，只是用于加速查询 12345create table table_1_1(name varchar(32),INDEX index_table_1_1_name(name));create table table_1_2 (name varchar(32));create INDEX index_table_1_2_name ON table_1_2(name); 2唯一索引索引列的值必须是唯一的，但是允许为空值，如果组合索引，则列支的组合必须是唯一的 12345create table table_2_1(name varchar(32),UNIQUE index_unique_table_2_1_name(name));create table table_2_2 (name varchar(32));create unique index index_unique_table_2_2_name ON table_2_2(name); 3.主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许为空，一般在建表的时候就需要同时创建主键索引 1create table table_3_1 (id int(11) not null auto_increment,name varchar(32),PRIMARY KEY(id)); 4组合索引多个字段上创建索引，只有在查询条件中使用创建索引的第一个字段，索引才会被使用，使用组合索引遵循最左前缀集合 123456create table table_4_1(id int(11),name varchar(32),index index_id_name(id,name) );create table table_4_2 (id int(11),name varchar(32));create index index_id_name on table_4_2(id,name); 5 全文索引主要是查找文本中的关键字，目前只支持char、varchar、text列可以创建索引 12345create table article_1 (content text null , fulltext(content));create table article_2 (content text null);create fulltext index index_artice_content on article_2(content);","link":"/2020/06/03/database/mysql-index/"},{"title":"node-sequelize","text":"node-orm【Sequelize】模型使用 安装Sequelize1npm i sequelize 驱动安装（选择以下其一） 12345npm install --save pg pg-hstore # Postgresnpm install --save mysql2npm install --save mariadbnpm install --save sqlite3npm install --save tedious # Microsoft SQL Server 连接数据库测试连接初次体验导入sequelize包 创建sequelize实例（通过实例构造方法传入参数创建连接数据库地址） .authenticate()函数测试连接是否正常 123456789101112const Sequelize = require('sequelize');const sequelize = new Sequelize('dog', 'root', '123456', { host: 'localhost', /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */ dialect: 'mysql' });try { sequelize.authenticate(); console.log(&quot;ok&quot;);} catch (err) { console.log(err)} 构造函数参数详解 https://sequelize.org/master/class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor 关闭连接默认情况下，在保持连接打开的状态，并对所有的查询使用相同的连接 1sequelize.close() 模型模型模型的本质其实是代表的是数据库中表的抽象，包含数据库表的名称以及该名称下所具有的列（以及列的数据类型） 模型定义-define方式1sequelize.define(modelName, attributes, options) 函数详解 https://sequelize.org/master/class/lib/sequelize.js~Sequelize.html#instance-method-define https://sequelize.org/master/class/lib/model.js~Model.html#static-method-init eg：定义一个user模型 123456789101112131415161718const {Sequelize,DataTypes} = require('sequelize');const sequelize = new Sequelize('dog', 'root', '123456', { host: 'localhost', dialect: 'mysql' });const User = sequelize.define('User',{ firstname:{ type:DataTypes.STRING, allowNull:false }, lastname:{ type:DataTypes.STRING, //allowNull 默认 true }},{ //其他模型参数});console.log(User === sequelize.models.User) 模型定义-init方式12345678910111213141516171819202122232425const { Sequelize, DataTypes, Model} = require('sequelize');const sequelize = new Sequelize('sequelize', 'root', '123456', { host: 'localhost', /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */ dialect: 'mysql'});class User extends Model {}User.init({ firstname: { type: DataTypes.STRING, allowNull: false, }, lastname: { type: DataTypes.STRING, }}, { sequelize, modelName: 'User'});console.log(User === sequelize.models.User) sequelize.define和model.init是等效的 字段属性设置默认值123456789const User = sequelize.define('User', { firstname: { type: DataTypes.STRING, defaultValue:&quot;zhiqiang&quot; }, ........}, { //其他模型参数}); 注释123456789const User = sequelize.define('User', { firstname: { type: DataTypes.STRING, defaultValue:&quot;zhiqiang&quot;, comment:&quot;注释&quot; },}, { //其他模型参数}); Type可用的字段类型数据库结构生成器包含构建表时可以指定的各种字段类型： 数据类型 方法名称 描述 字符串 DataTypes.STRING VARCHAR(255) DataTypes.STRING(100) VARCHAR(100) DataTypes.STRING.BINARY VARCHAR BINARY DataTypes.TEXT TEXT DataTypes.TEXT(‘tiny’) TINYTEXT DataTypes.CITEXT CITEXT 仅 PostgreSQL 和 SQLite. 布尔 DataTypes.BOOLEAN TINYINT(1) 数字 DataTypes.INTEGER INTEGER DataTypes.BIGINT BIGINT DataTypes.BIGINT(11) BIGINT(11) DataTypes.FLOAT FLOAT DataTypes.FLOAT(11) FLOAT(11) DataTypes.FLOAT(11, 10) FLOAT(11,10) DataTypes.REAL REAL 仅 PostgreSQL DataTypes.REAL(11) REAL(11) 仅 PostgreSQL. DataTypes.REAL(11, 12) REAL(11,12) 仅 PostgreSQL. DataTypes.DOUBLE DOUBLE DataTypes.DOUBLE(11) DOUBLE(11) DataTypes.DOUBLE(11, 10) DOUBLE(11,10) DataTypes.DECIMAL DECIMAL DataTypes.DECIMAL(10, 2) DECIMAL(10,2) DataTypes.INTEGER.UNSIGNED MySQL 和 MariaDB 设置为无符号或零填充 DataTypes.INTEGER.ZEROFILL MySQL 和 MariaDB设置为无符号或零填充 DataTypes.INTEGER.UNSIGNED.ZEROFILL MySQL 和 MariaDB设置为无符号或零填充 日期 DataTypes.DATE DATETIME 适用于 mysql / sqlite, DataTypes.DATE(6) DATETIME(6) 适用于 mysql 5.6.4+ DataTypes.DATEONLY 不带时间的 DATE UUID DataTypes.UUID 对于 PostgreSQL 和 SQLite,它会是 UUID 数据类型，对于mysql会变成char(36),UUID默认值设置 1234{ type: DataTypes.UUID, defaultValue: Sequelize.UUIDV4 // 或 Sequelize.UUIDV1} 其他属性设置表名复数 自定义表名 表名复数在默认情况下，关联到数据库的表名为Users 增加配置 去掉复数的方式 方式一：全局配置，在实例化的时候增加freezeTableName配置 1234567const sequelize = new Sequelize('sequelize', 'root', '123456', { host: 'localhost', dialect: 'mysql', define: { freezeTableName :true }}); 方式二：单独模型配置 12345678// define 方式定义模型const User = sequelize.define('User', { .........}, { //其他模型参数 //强制表名和模型名称保持一致 freezeTableNAme: true}); 自定义表名1234567const User = sequelize.define('User', { .....}, { //其他模型参数 // 自定义表名 tableName:&quot;zq_user&quot;}); 时间戳createdAt/updatedAt1234567891011// define 方式定义模型const User = sequelize.define('User', { .....}, { // 去掉createdAt/updatedAt // timestamps:false // 去掉 createdAt // createdAt:false, // //去掉 updatedAt // updatedAt:false,}); 模型同步表123456789// //用户模型同步到数据库中// User.sync({force:true})//生成的sqlCREATE TABLE IF NOT EXISTS `zq_user` (`id` INTEGER NOT NULL auto_increment , `firstname` VARCHAR(255) NOT NULL, `lastname` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;// //一次性同步所有的// sequelize.sync({force:true}) 删除表1234// 删除指定用户表// User.drop();// 删除所有的表// sequelize.drop();","link":"/2020/06/09/database/node-sequelize/"},{"title":"acme.sh","text":"acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书. 主要步骤: 安装 acme.sh 生成证书 copy 证书到 nginx/apache 或者其他服务 更新证书 下面详细介绍. 1. 安装 acme.sh12345678910# sh 安装curl https://get.acme.sh | sh# 源码安装git clone https://github.com/acmesh-official/acme.sh.gitcd ./acme.sh./acme.sh --install# 创建 一个 bash 的 aliasalias acme.sh=~/.acme.sh/acme.sh 2. 生成证书在生成之前，确保你的域名可以正常访问到webroot目录下 1acme.sh --issue -d www.zqw.xyz --webroot /wwwroot/zqw.xyz/ 3. copy/安装 证书123456mkdir -p /etc/nginx/sslacme.sh --installcert -d www.zqw.xyz \\--key-file /etc/nginx/ssl/www.zqw.xyz.key \\--fullchain-file /etc/nginx/ssl/www.zqw.xyz.cer \\--reloadcmd &quot;service nginx force-reload&quot; 4. 更新证书目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心. 详细文档 https://github.com/acmesh-official/acme.sh/wiki","link":"/2021/01/14/liunx/acme-sh/"},{"title":"mysql用户篇","text":"用户管理 权限管理 数据备份还原 用户创建用户1234567891011121314-- 创建用户，并允许其在任何IP登陆create user 'username'@'%' identified by 'password';-- 创建用户，并允许其在任何主机登陆，不设置密码create user 'username'@'%';-- 创建用户，并仅允许使用domian.com域名的主机登陆create user 'username'@'domian.com' identified by 'password';-- 创建用户，并仅允许使用192.168.1.1的主机登陆create user 'username'@'192.168.1.1' identified by 'password';-- 创建用户，并仅允许使用192.168.1开头的主机登陆create user 'username'@'192.168.1.%' identified by 'password'; 密码可以为空，如为空，则可以免密登陆 如果主机位使用 %，表示允许任意地址的主机登陆 主机位可以使用域名或者 IP 地址，但是不允许既有数字又有字母 主机位中可以使用 % 进行通配，例如：%.domian.com 或 192.168.1.% 修改用户123456rename user 'old_username'@'old_ip_addr' to 'new_username'@'new_ip_addr';set password for 'username'@'ip_addr'=Password('new_password');//修改完密码，需将配置刷到内存flush privileges; 删除用户1drop user 'username'@'ip_addr'; 用户权限查看权限1show grants for 'username'@'ip_addr'; 权限授予1234567891011121314-- 授予用户所有库所有表的所有权限grant all privileges on *.* to 'username'@'ip_addr';-- 授予用户database1库所有表的所有权限grant all privileges on `database1`.* to 'username'@'ip_addr';-- 授予用户database1库table1表的所有权限grant all privileges on `database1`.`table1` to 'username'@'ip_addr';-- 授予用户database1库所有表的只读权限grant select on `database1`.* to 'username'@'ip_addr';-- 授予用户database1库table1表的插入、更新权限grant insert,update on `database1`.`table1` to 'username'@'ip_addr'; 权限回收12345-- 回收用户所有权限revoke all,grant option from 'username'@'ip_addr';-- 回收用户database1库所有表的只读权限revoke select ON `database1`.* FROM 'username'@'%'; 备份与恢复12345678910-- 备份database1库所有表结构+数据mysqdump -u username database1 &gt; database1.sql -p-- 备份database1库所有表结构mysqdump -u username -d database1 &gt; database1.sql -p-- 进入数据库use database1;-- 将备份文件恢复到数据库中mysqdump -u username -d database1 &lt; database1.sql -p 常用权限列表 权 限 作用范围 作 用 all 服务器 所有权限 select 表、列 选择行 insert 表、列 插入行 update 表、列 更新行 delete 表 删除行 create 数据库、表、索引 创建 drop 数据库、表、视图 删除 reload 服务器 允许使用flush语句 shutdown 服务器 关闭服务 process 服务器 查看线程信息 file 服务器 文件操作 grant option 数据库、表、存储过程 授权 references 数据库、表 外键约束的父表 index 表 创建/删除索引 alter 表 修改表结构 show databases 服务器 查看数据库名称 super 服务器 超级权限 create temporary tables 表 创建临时表 lock tables 数据库 锁表 execute 存储过程 执行 replication client 服务器 允许查看主/从/二进制日志状态 replication slave 服务器 主从复制 create view 视图 创建视图 show view 视图 查看视图 create routine 存储过程 创建存储过程 alter routine 存储过程 修改/删除存储过程 create user 服务器 创建用户 event 数据库 创建/更改/删除/查看事件 trigger 表 触发器 create tablespace 服务器 创建/更改/删除表空间/日志文件 proxy 服务器 代理成为其它用户 usage 服务器 没有权限","link":"/2020/07/04/database/mysql-user/"},{"title":"软件开发流程","text":"一、产品爸爸提需求二、需求评审三、技术方案设计四、技术设计评审五、排期六、开发七、code review八、测试九、上线十、上线后回测 PM：产品经理 PM：项目经理 UE：交互设计师，负责页面布局、交互的设计，不负责视图的细节。 UI：视觉设计师，交互确定之后，设计页面样式。注意，很多情况下，UE 和 UI 是一个人。 RD：后端开发人员。 CRD：客户端开发人员，安卓和 ios 都是。 FE：前端开发人员。 QA：测试人员。 OP：服务器运维人员，一般负责审批上线单。 一、产品爸爸提需求产品爸爸们通过对用户的分析和反馈，还有多年行业经验，以及同行之间产品分析，YY出了很多的产品需求，做好这些需求设计之后，就得他们的产品总监和其他产品内部评审这份设计。产品总监认可之后的需求。产品爸爸们就会拿着需求来折磨我们这些程序员了。 二、需求评审产品爸爸拉上各种开发人员，比如APP、Java后端、前端、UE交互、UI设计、QA测试等等，进行这个需求的评审。每个人对这个需求各抒己见，哪些地方不合理，哪些地方这期不适合开发等等，产品会做会议记录邮件，然后更改需求，如果改动较小，就以邮件形式通知各位开发们，如果改动较大，还需进行二次评审。 三、技术方案设计产品爸爸发话了，那就得干啊，然后后端开始做技术详细设计，UE做交互稿，QA做测试用例，UI根据UE的交互稿做页面设计。 后端的技术方案设计非常重要，这一步其实是对产品业务的一个梳理过程，让你能够更加了解业务需求，在设计的过程中能够及时发现哪里不合理，哪里有风险，哪里用什么样的技术栈等等。能让你在写代码的时候，速度又快，质量又高的完成开发工作。 四、技术设计评审 这里有几个方面需要评审，UE的交互稿，QA的测试用例，这个是需要全体人员进行参加的。而后端的技术方案设计，只需要技术leader和一些组内技术人员参加评审即可，因为其他人参加也听不懂嘛。这个技术评审能让你学到很多东西，对业务的风险把控，技术栈的选择等等，leader会针对这些给你提一些专业性的意见。所以技术方案一定要做好，这也是领导了解你的一个过程。你每次都做的很详细，很靠谱，那以后有好项目领导肯定会优先考虑交给你做。 五、排期进入开发前要先进行工作量排期，就是工作计划安排，今天干什么，明天干什么，这个排期非常重要，排期有时候能直接影响你是996还是965， 因为严格控制排期，按照排期计划走，能让你比较从容的开发，各个环节有条不紊的进行。但是如果情况特殊，就是有好几个需求并行开发，时间都特别紧急，那排期也救不了你了。比如到了双十一大促，618大促，那都是很忙的时候。 六、 开发以上都搞完之后就可以进入真正的开发了，首先前后端要进行mock接口定义， 提供一些mock数据给前端等等，因为目前都是前后端分离的开发模式，双方定义好接口交互方式，就可以各自干活了，相当于并行开发。这样的工作效率非常高，谁也不用等谁。双方开发完之后就进入联调，前端切换成后端的真实接口，然后双方进行自测。 七、 code review 开发工作全部完毕之后，进入代码review阶段，这个时候一般是叫上leader和组内的其他技术人员参加，他们会根据业务背景，以及你的代码实现提出一些意见，比如这里用工厂设计模式比较好，或者这里的代码逻辑可以在优化一下等等，这个阶段也是一个非常好的学习过程，你写代码都是按照自己的知识储备和风格去写，别人从他们自己的知识储备来看你的代码，会提出不同的思路，这样你就能学习他人的一些知识。 八、测试 以上都做完之后就进入测试阶段了，写个提测邮件给测试爸爸们，心里祈祷着千万别测试bug，结果测试爸爸们立马给你发了一条钉钉消息：英雄来干了这碗bug。测试一般分为测试环境和沙箱环境，测试环境又细分了很多子环境，比如stable环境、betaa环境、betab、betac、betad环境等，为什么要搞这么多测试环境呢，因为可能会有很多需求并行在开发，就需要很多环境来测试这些需求。一般中小型公司就没这么多环境。那么沙箱环境又是什么呢，就是模拟线上环境，几乎和线上环境是一模一样的，就是为了在上线前能够保证不出任何问题，因为上线是一件特别神圣的事，一旦出问题，你就背锅吧。测试完成后产品进行验收，产品爸爸满意了，这个时候就可以上线了。 九、上线上线是一件非常神圣又庄严的事情，一般老哥都会先沐浴更衣之后在执行上线，因为一旦上线出问题，那就没时间洗脸洗澡了。上线前要做很多准备工作，列出一份上线清单，把上线涉及的影响点全部列出来给QA。比如是否有数据库工单，是否申请了ES索引等等，集群上线顺序，出现问题回滚顺序等等，万事俱备之后，就开始神圣的上线了。 十、上线后回测 不要以为上完线就万事大吉可以开溜了，QA还需要回测此次版本涉及的功能点，这个时候就得祈祷了，千万别有什么问题，要不今晚又回不去家了，如果上线出现问题不能短时间解决，最好的方法就是回滚，回滚到上一个可用版本。如果没有任何问题，这个时候产品爸爸就要登场了，来验收你的劳动成果，产品爸爸点头了就可以收拾东西回家睡觉了。","link":"/2020/06/28/management/development-process/"},{"title":"宝塔linux面板命令大全","text":"安装命令 管理宝塔命令 nginx服务 apache服务 mysql服务 ftp服务 php服务 redis服务 memcahed服务 安装宝塔Centos安装脚本 1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本 1wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh Debian安装脚本 1wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh Fedora安装脚本 1wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 管理宝塔宝塔工具箱(包含下列绝大部分功能 直接ssh中执行bt命令 仅限6.x以上版本面板) 1bt 停止 1/etc/init.d/bt stop 启动 1/etc/init.d/bt start 重启 1/etc/init.d/bt restart 卸载 1/etc/init.d/bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f /etc/init.d/bt &amp;&amp; rm -rf /www/server/panel 查看当前面板端口 1cat /www/server/panel/data/port.pl 修改面板端口，如要改成8881（centos 6 系统） 1234echo '8881' &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restartiptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 8881 -j ACCEPTservice iptables saveservice iptables restart 修改面板端口，如要改成8881（centos 7 系统） 123echo '8881' &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restartfirewall-cmd --permanent --zone=public --add-port=8881/tcpfirewall-cmd --reload 强制修改MySQL管理(root)密码，如要改成123456 1cd /www/server/panel &amp;&amp; python tools.py root 123456 修改面板密码，如要改成123456 1cd /www/server/panel &amp;&amp; python tools.py panel 123456 查看宝塔日志 1cat /tmp/panelBoot.pl 查看软件安装日志 1cat /tmp/panelExec.log 站点配置文件位置 1/www/server/panel/vhost 删除域名绑定面板 1rm -f /www/server/panel/data/domain.conf 清理登陆限制 1rm -f /www/server/panel/data/*.login 查看面板授权IP 1cat /www/server/panel/data/limitip.conf 关闭访问限制 1rm -f /www/server/panel/data/limitip.conf 查看许可域名 1cat /www/server/panel/data/domain.conf 关闭面板SSL 1rm -f /www/server/panel/data/ssl.pl &amp;&amp; /etc/init.d/bt restart 查看面板错误日志 1cat /tmp/panelBoot 查看数据库错误日志 1cat /www/server/data/*.err 站点配置文件目录(nginx) 1/www/server/panel/vhost/nginx 站点配置文件目录(apache) 1/www/server/panel/vhost/apache 站点默认目录 1/www/wwwroot 数据库备份目录 1/www/backup/database 站点备份目录 1/www/backup/site 站点日志 1/www/wwwlogs Nginx服务管理nginx安装目录 1/www/server/nginx 启动 1/etc/init.d/nginx start 停止 1/etc/init.d/nginx stop 重启 1/etc/init.d/nginx restart 启载 1/etc/init.d/nginx reload nginx配置文件 1/www/server/nginx/conf/nginx.conf Apache服务管理apache安装目录 1/www/server/httpd 启动 1/etc/init.d/httpd start 停止 1/etc/init.d/httpd stop 重启 1/etc/init.d/httpd restart 启载 1/etc/init.d/httpd reload apache配置文件 1/www/server/apache/conf/httpd.conf MySQL服务管理mysql安装目录 1/www/server/mysql phpmyadmin安装目录 1/www/server/phpmyadmin 数据存储目录 1/www/server/data 启动 1/etc/init.d/mysqld start 停止 1/etc/init.d/mysqld stop 重启 1/etc/init.d/mysqld restart 启载 1/etc/init.d/mysqld reload mysql配置文件 1/etc/my.cnf FTP服务管理ftp安装目录 1/www/server/pure-ftpd 启动 1/etc/init.d/pure-ftpd start 停止 1/etc/init.d/pure-ftpd stop 重启 1/etc/init.d/pure-ftpd restart ftp配置文件 1/www/server/pure-ftpd/etc/pure-ftpd.conf PHP服务管理php安装目录 1/www/server/php 启动(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 start) 1/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} start 停止(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 stop) 1/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} stop 重启(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 restart) 1/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} restart 启载(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 reload) 1/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} reload 配置文件(请根据安装PHP版本号做更改，例如：/www/server/php/52/etc/php.ini) 1/www/server/php/{52|53|54|55|56|70|71|72|73|74}/etc/php.ini Redis服务管理redis安装目录 1/www/server/redis 启动 1/etc/init.d/redis start 停止 1/etc/init.d/redis stop redis配置文件 1/www/server/redis/redis.conf Memcached服务管理memcached安装目录 1/usr/local/memcached 启动 1/etc/init.d/memcached start 停止 1/etc/init.d/memcached stop 重启 1/etc/init.d/memcached restart 启载 1/etc/init.d/memcached reload","link":"/2020/07/07/liunx/liunx-centos-bt/"},{"title":"gitlab&amp;gitlab-runner","text":"gitlab安装 gitlab-runner安装 yum 安装gitlab https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/ 12345678910111213wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-13.4.6-ce.0.el7.x86_64.rpmrpm -ivh gitlab-ce-13.4.6-ce.0.el7.x86_64.rpm修改配置文件vim /etc/gitlab.rb//重新加载配置文件gitlab-ctl reconfigure//服务控制gitlab-ctl startgitlab-ctl statusgitlab-ctl stop docker 安装gitlab 12345678910111213141516mkdir -p /data/gitlab-ce/etc /data/gitlab-ce/logs /data/gitlab-ce/datadocker run -d -p 8080:80 -p 443:443 -p 222:22 --name gitlab --restart always-v /data/gitlab-ce/etc:/etc/gitlab-v /data/gitlab-ce/logs:/var/logs/gitlab-v /data/gitlab-ce/data:/var/opt/gitlabgitlab/gitlab-cedocker exec -it gitlab bashvim /etc/gitlab.rbgitlab-ctl reconfiguredocker start gitlabdocker stop gitlanbdocker rm gitlab yum 安装 gitlab-runner https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/ 123wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/gitlab-runner-13.4.1-1.x86_64.rpmrpm -ivh gitlab-runner-13.4.1-1.x86_64.rpmsystemctl start gitlab-runner docker安装gitlab-runner 12345docker pull gitlab/gitlab-runner:v13.4.1mkdir -p /data/gitlab-runner/etcdocker run -d --name gitlab-runner --restart always -v /data/gitlab-runner/etc:/etc/gitlab-runner gitlab/gitlab-runner:v13.4.1","link":"/2020/11/21/liunx/gitlab-gitlab-runner/"},{"title":"centos安装OpenResty api 网关 Orange","text":"安装依赖 openresty安装 luarocks安装 mariadb安装 安装lor 启动并配置 orange 服务 OpenResty api网关设计，主要涉及api网关介绍、openresty api网关 请求路由（路由判断、路由重写、服务判断、限流）、授权验证（统一认证）、动态Upstream 以及这三部分理论简单实现的Api网关和Api网关admin。 安装依赖1yum -y install libuuid-devel pcre-devel openssl-devel gcc-c++ wget perl-Time-HiRes perl-Digest-MD5 openresty安装编译安装https://openresty.org/cn/download.html 12345wget https://openresty.org/download/openresty-1.13.6.1.tar.gztar xf openresty-1.13.6.1.tar.gz cd openresty-1.13.6.1./configure --prefix=/usr/local/openresty --with-http_stub_status_module --with-http_v2_module --with-http_ssl_modulegmake &amp;&amp; gmake install apt安装https://openresty.org/cn/linux-packages.html 12345apt install --no-install-recommends wget gnupg ca-certificateswget -O - https://openresty.org/package/pubkey.gpg | sudo apt-key add -sudo add-apt-repository -y &quot;deb http://openresty.org/package/ubuntu $(lsb_release -sc) main&quot;apt updateapt install -y openresty luarocks安装https://luarocks.org/ 123456789wget https://luarocks.org/releases/luarocks-2.4.1.tar.gzcd luarocks-2.4.1/./configure --prefix=/usr/local/openresty/luajit \\ --with-lua=/usr/local/openresty/luajit/ \\ --lua-suffix=jit \\ --with-lua-include=/usr/local/openresty/luajit/include/luajit-2.1make build# 安装需要root权限sudo make install 环境变量设置12345cat /etc/profile.d/openresty.sh export OPENRESTY_HOME=/usr/local/openrestyexport NGINX_HOME=$OPENRESTY_HOME/nginxexport PATH=$OPENRESTY_HOME/bin:$NGINX_HOME/sbin:$PATHsource /etc/profile mariadb安装https://downloads.mariadb.org/mariadb/repositories/ 1234567891011121314151617181920212223242526272829303132rpm -e mysql-*rpm -qa | grep mariadbyum remove mysql mysql-server mysql-libs compat-mysql51vi /etc/yum.repos.d/MariaDB.repo # MariaDB 10.4 CentOS repository list - created 2019-09-28 03:16 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = http://yum.mariadb.org/10.4/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1yum -y install MariaDB-server mysql_secure_installation首先是设置密码，会提示先输入密码 Enter current password for root (enter for none):&lt;–初次运行直接回车Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车New password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 再输入一次你设置的密码Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车（后面授权配置）Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车 Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车 mysql -uroot -pCREATE USER 'orange'@'%' IDENTIFIED BY 'orange'; GRANT ALL PRIVILEGES ON orange.* TO 'orange'@'%';FLUSH PRIVILEGES; 安装lor1234yum install -y gitgit clone https://github.com/sumory/lor.gitcd lormake install 启动并配置 orange 服务https://github.com/orlabs/orange/blob/master/README_zh.md 12345678910111213141516service iptables stopchkconfig iptables offgit clone https://github.com/sumory/orange.gitcd orange// orange 根目录 luarocks install luafilesystemluarocks install luasocketluarocks install lrandom// 安装 orange 依赖包 opm --install-dir=./ get zhangbao0325/orangelib //配置文件cd confcp orange.conf.example orange.confcp nginx.conf.example nginx.confcd install/mysql -u orange -porange -h 127.0.0.1 orange &lt; orange-v0.6.2.sql","link":"/2020/08/20/liunx/openresty/"},{"title":"nginx反向代理配置文件","text":"nginx反向代理配置 1234567891011121314server { listen 80; server_name proxy.domain.com; gzip on; error_log logs/proxy.log; location / { proxy_pass http://localhost:4000; proxy_redirect default; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; }}","link":"/2020/11/20/liunx/nginx-location-proxy/"},{"title":"响应状态码解释","text":"2xx状态码 3xx状态码 4xx状态码 5xx状态码 201-206都表示服务器成功处理了请求的状态代码，说明网页可以正常访问。200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201（已创建） 请求成功且服务器已创建了新的资源。 202（已接受） 服务器已接受了请求，但尚未对其进行处理。 203（非授权信息） 服务器已成功处理了请求，但返回了可能来自另一来源的信息。 204（无内容） 服务器成功处理了请求，但未返回任何内容。 205（重置内容） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 206（部分内容） 服务器成功处理了部分 GET 请求。 300-307表示的意思是：要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。300（多种选择） 服务器根据请求可执行多种操作。服务器可根据请求者 来选择一项操作，或提供操作列表供其选择。 301（永久移动） 请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。 302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎页面或网站已被移动。 303（查看其他位置） 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 304（未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应。由于服务器可以告诉 搜索引擎自从上次抓取后网页没有更改过，因此可节省带宽和开销。 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 307（临时重定向） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎某个页面或网站已被移动。 4XXHTTP状态码表示请求可能出错，会妨碍服务器的处理。400（错误请求） 服务器不理解请求的语法。 401（身份验证错误） 此页要求授权。您可能不希望将此网页纳入索引。 403（禁止） 服务器拒绝请求。 404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 405（方法禁用） 禁用请求中指定的方法。 406（不接受） 无法使用请求的内容特性响应请求的网页。 407（需要代理授权） 此状态码与 401 类似，但指定请求者必须授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时） 服务器等候请求时发生超时。 409（冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除） 请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久删除，您应当使用 301 指定资源的新位置。 411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值） 服务器未满足”期望”请求标头字段的要求。 500至505表示的意思是：服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到了无效的响应。 503（服务不可用） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 504（网关超时） 服务器作为网关或代理，未及时从上游服务器接收请求。 505（HTTP的 版本不受支持） 服务器不支持请求中所使用的 HTTP 协议版本。","link":"/2021/01/31/net/httpcode/"},{"title":"Easyswoole中实现think-template模板引擎使用","text":"五步走，在easyswoole中使用think-template模板引擎 安装 基础功能实现 mainServerCreate函数注册初始化 在控制器中使用 模版渲染文件 详细语言描述看官网：https://www.easyswoole.com/Cn/Components/template.html 安装12composer require easyswoole/templatecomposer require topthink/think-template 基础类实现App/Providers/ThinkTpl.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\Providers;use EasySwoole\\Template\\RenderInterface;class ThinkTpl implements RenderInterface{ protected $template; public function __construct() { $this-&gt;template = new \\think\\Template([ 'view_path' =&gt; EASYSWOOLE_ROOT.'/App/Views/', 'cache_path' =&gt; EASYSWOOLE_ROOT.'/Temp/runtime/', ]); } public function render(string $template, array $data = [], array $options = []): ?string { // TODO: Implement render() method. ob_start(); $this-&gt;template-&gt;assign($data); $this-&gt;template-&gt;fetch($template); $content = ob_get_contents() ; return $content; } public function afterRender(?string $result, string $template, array $data = [], array $options = []) { // TODO: Implement afterRender() method. } public function onException(\\Throwable $throwable): string { // TODO: Implement onException() method. $msg = &quot;{$throwable-&gt;getMessage()} at file:{$throwable-&gt;getFile()} line:{$throwable-&gt;getLine()}&quot;; trigger_error($msg); return $msg; }} mainServerCreate函数注册初始化123456use EasySwoole\\Template\\Render;use App\\Providers\\ThinkTpl;$render = Render::getInstance();$render-&gt;getConfig()-&gt;setRender(new ThinkTpl());$render-&gt;attachServer(ServerManager::getInstance()-&gt;getSwooleServer()); 控制器使用12345678910111213// 该方法放在控制器基类中，为以后提供方便public function fetch($tpl='', $data=[]){ if($tpl == ''){ $tpl = $this-&gt;getActionName(); } $this-&gt;response()-&gt;write(Render::getInstance()-&gt;render($tpl,$data));}//在某个控制器中的index方法public function index(){ return $this-&gt;fetch();} 页面渲染App/Views/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;easyswoole think-template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello EasySwoole think-template&lt;/body&gt;&lt;/html&gt;","link":"/2020/06/23/php/easyswoole-think-template/"},{"title":"easyswoole 基础入坑进行时","text":"easyswoole 基础入坑,更多详细文档请参考https://www.easyswoole.com/Cn/Preface/introduction.html 基础基础环境需求 保证 PHP 版本大于等于 7.1 保证 Swoole 拓展版本大于等于 4.4.15 需要 pcntl 拓展的任意版本 使用 Linux / FreeBSD / MacOS 这三类操作系统 使用 Composer 作为依赖管理工具 Composer安装12composer require easyswoole/easyswoole=3.xphp vendor/easyswoole/easyswoole/bin/easyswoole install 目录结构EasySwoole 的目录结构是非常灵活的，基本上可以任意定制，没有太多的约束，但是仍然建议遵循下面的目录结构，方便开发 1234567891011121314project 项目部署目录├─App 应用目录(可以有多个)│ ├─HttpController 控制器目录│ │ └─Index.php 默认控制器│ └─Model 模型文件目录├─Log 日志文件目录├─Temp 临时文件目录├─vendor 第三方类库目录├─composer.json Composer架构├─composer.lock Composer锁定├─EasySwooleEvent.php 框架全局事件├─easyswoole 框架管理脚本├─dev.php 开发配置文件├─produce.php 生产配置文件 配置配置文件dev.php https://www.easyswoole.com/Cn/QuickStart/config.html 1234567891011121314151617181920212223&lt;?phpreturn [ 'SERVER_NAME' =&gt; &quot;EasySwoole&quot;, 'MAIN_SERVER' =&gt; [ 'LISTEN_ADDRESS' =&gt; '0.0.0.0', 'PORT' =&gt; 9501, 'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SERVER, 'SOCK_TYPE' =&gt; SWOOLE_TCP, 'RUN_MODEL' =&gt; SWOOLE_PROCESS, 'SETTING' =&gt; [ 'worker_num' =&gt; 8, 'reload_async' =&gt; true, 'max_wait_time'=&gt;3 ], 'TASK'=&gt;[ 'workerNum'=&gt;4, 'maxRunningNum'=&gt;128, 'timeout'=&gt;15 ] ], 'TEMP_DIR' =&gt; '/tmp/easyswoole/', 'LOG_DIR' =&gt; null]; 服务名称查看 1ps -ef | grep EasySwoole 配置文件操作类配置功能由\\EasySwoole\\EasySwoole\\Config类完成。 配置加载在easyswoole配置加载目前支持有三种方式 加载配置配置文件，如：默认的dev.php一样的配置文件 1\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;loadFile($file); 加载env配置文件 1\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;loadEnv($envfile); 加载数组 1\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;load($conf); 读取配置 读取单个配置信息 1\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf($keyPath); 读取全部配置信息 1\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;getConf(); 动态配置1\\EasySwoole\\EasySwoole\\Config::getInstance()-&gt;setConf($keyPath,$data); 配置文件驱动方式123EasySwoole\\Config\\TableConfigEasySwoole\\Config\\SplArrayConfig 自定义，参考一下官方文档自定义config驱动写法 由于swoole是多进程的,如果使用SplArray方式存储,在单个进程修改配置后,其他进程将不会生效,使用swoole_table方式的则会全部生效,需要注意 助手函数123456789101112use EasySwoole\\EasySwoole\\Config as GlobalConfig;if (!function_exists(&quot;config&quot;)) { function config($name = '', $value = null) { $instance = GlobalConfig::getInstance(); if (is_null($value) &amp;&amp; is_string($name)) { return $instance-&gt;getConf($name); } else { return $instance-&gt;setConf($name, $value); } }} 控制器控制器的主要作用是request和response对象进行数据交互，详细的介绍，见官方文档：https://www.easyswoole.com/Cn/HttpServer/controller.html 主要继承EasySwoole\\Http\\AbstractInterface\\Controller类和其他的控制器类 定义控制器 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\HttpController;use EasySwoole\\Http\\AbstractInterface\\Controller;class User extends Controller{ public function onRequest(string $action): ?bool { $this-&gt;response()-&gt;write(&quot;this is user onRequest\\n&quot;); return true; } public function index() { $this-&gt;response()-&gt;write(&quot;this is user index\\n&quot;); } public function afterAction(string $actionName): void { $this-&gt;response()-&gt;write(&quot;this is afterAction\\n&quot;); } public function gc() { $this-&gt;response()-&gt;write(&quot;this is gc\\n&quot;); } public function onException(\\Throwable $throwable): void { $this-&gt;response()-&gt;write($throwable-&gt;getMessage()); } public function actionNotFound(string $action) { $this-&gt;response()-&gt;write(&quot;404\\n&quot;); }} 控制器类文件的实际位置是 1App/HttpController/User.php 访问格式： 1http://127.0.0.1:9501/user/index 执行的结果 1234this is user onRequestthis is user indexthis is afterActionthis is gc index方法：是一个抽象方法，可以随意定义，但是导致的结果只会是路由变化，如方法名称是info那么你访问的路由也就是/user/info onRequest方法：是来源父类的方法，是在请求该控制器该方法之前去执行，我们可以在这里放置权限管理，登录业务逻辑处理等操作 afterAction方法，来源于父类的方法，当控制器方法执行结束之后将调用该方法,可自定义数据回收等逻辑‘ gc 方法将在执行方法,afterAction完之后自动调用,将控制器属性重置为默认值,关闭session可自行覆盖实现其他的gc回收逻辑. onException当控制器逻辑抛出异常时将调用该方法进行处理异常(框架默认已经处理了异常)可覆盖该方法,进行自定义的异常处理。 actionNotFound当请求方法未找到时,自动调用该方法,可自行覆盖该方法实现自己的逻辑 请求Request12345678910111213141516171819202122$req = $this-&gt;request();// 用于获取用户通过POST或者GET提交的参数$data = $req-&gt;getRequestParam();//获取cookies信息$cookies = $req-&gt;getCookieParams();//获取上传文件信息$file = $req-&gt;getUploadedFile(&quot;img&quot;);//获取多个文件信息$file = $req-&gt;getUploadedFiles();//获得get内容$get = $req-&gt;getQueryParams();//获得post内容$post = $req-&gt;getParsedBody();//获得raw内容$content = $req-&gt;getBody()-&gt;__toString();$raw_array = json_decode($content, true);//获得头部$header = $req-&gt;getHeaders();//获得server$server = $req-&gt;getServerParams();//获得cookie$cookie = $req-&gt;getCookieParams(); 响应Rseponse123456789// 向页面输出hello world 字符串，同时也只能传入字符串$this-&gt;response()-&gt;write('hello world');//重定向(可路由可外)$this-&gt;response()-&gt;redirect(&quot;/user&quot;);// json数据$this-&gt;writeJson(200,$data,'success');{&quot;code&quot;:200,&quot;result&quot;:{},&quot;msg&quot;:&quot;success&quot;}","link":"/2020/06/22/php/easyswoole-basis/"},{"title":"在centos7环境下安装配置php7","text":"centos7操作系统下使用php编程语言 安装依赖123456789101112yum install -y epel-releaseyun update -y yum install -y autoconf curl-devel openssl openssl-devel openssl openssl-devel gcc gcc-c++ libxml2 libxml2-devel libpng libpng-devel bzip2 bzip2-devel freetype-devel libicu-devel libjpeg-develwget https://nih.at/libzip/libzip-1.2.0.tar.gztar -zxvf libzip-1.2.0.tar.gzcd libzip-1.2.0./configuremake &amp;&amp; make install cp /usr/local/lib/libzip/include/zipconf.h /usr/local/include/zipconf.h 下载解压1234567wget https://www.php.net/distributions/php-7.3.13.tar.gztar -xzvf php-7.3.13.tar.gzcd php-php-7.3.13/wget https://www.php.net/distributions/php-7.2.31.tar.gztar -xzvf php-7.2.31.tar.gzcd php-7.2.31/ 参数编译1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162./configure --prefix=/usr/local/php7 \\--enable-fpm \\--enable-shared \\--enable-soap \\--enable-bcmath \\--enable-calendar \\--enable-ftp \\--enable-dom \\--enable-exif \\--enable-fileinfo \\--enable-filter \\--enable-gd-jis-conv \\--enable-json \\--enable-mbstring \\--enable-mbregex \\--enable-mbregex-backtrack \\--enable-session \\--enable-shmop \\--enable-simplexml \\--enable-pcntl \\--enable-sockets \\--enable-sysvmsg \\--enable-sysvsem \\--enable-sysvshm \\--enable-wddx \\--enable-zip \\--enable-mysqlnd-compression-support \\--enable-opcache \\--enable-inline-optimization \\--enable-intl \\--enable-simplexml \\--enable-xmlreader \\--enable-xmlwriter \\--disable-phpdbg \\--disable-phpdbg-webhelper \\--disable-debug \\--disable-rpath \\--with-xmlrpc \\--with-openssl \\--with-pcre-regex \\--with-sqlite3 \\--with-zlib \\--with-iconv \\--with-bz2 \\--with-curl \\--with-cdb \\--with-pcre-dir \\--with-gd \\--with-openssl-dir \\--with-jpeg-dir \\--with-png-dir \\--with-freetype-dir \\--with-gettext \\--with-mhash \\--with-libmbfl \\--with-onig \\--with-mysqli=shared,mysqlnd \\--with-pdo-mysql=shared,mysqlnd \\--with-zlib-dir \\--with-pdo-sqlite \\--with-pear \\--with-libxml-dir 开始make安装1make &amp;&amp; make install 环境变量以及配置文件拷贝1234567891011//加入永久环境变量中vi /etc/profileexport PATH=/usr/local/php7/bin:$PATHsource /etc/profile// 为了防止环境变量设置错误导致无法执行ls等基本命令，处理方案export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin//配置文件拷贝到指定的目录php -i | grep php.inicp php.ini-development /usr/local/php7/lib/php.ini 配置php-fpm服务1234567891011# 创建www组groupadd www# 创建一个用户归属www组useradd -g www wwwcp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.confcp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf//编辑php-fpm.conf 去掉注释vim /usr/local/php7/etc/php-fpm.confpid = run/php-fpm.pid fpm命令123456789101112131415161718192021222324252627测试php-fpm配置/usr/local/php7/sbin/php-fpm -t/usr/local/php7/sbin/php-fpm -c /usr/local/php7/etc/php.ini -y /usr/local/php7/etc/php-fpm.conf -t//自定义加载配置信息启动/usr/local/php7/sbin/php-fpm -c /usr/local/php7/lib/php.ini -y /usr/local/php7/etc/php-fpm.conf//pid 获取ps aux | grep phpcat /usr/local/php7/var/run/php-fpm.pidphp-fpm信号控制INT, TERM 立刻终止QUIT 平滑终止USR1 重新打开日志文件USR2 平滑重载所有worker进程并重新载入配置和二进制模块//重启php-fpm:kill -USR2 pidkillall -9 php-fpm//关闭php-fpmkill -INT `cat /usr/local/php7/var/run/php-fpm.pid`或pkill php-fpm 扩展安装pecl方式12pecl install redisecho extension=redis.so &gt;&gt;/usr/local/php7/lib/php.ini 编译安装123456789101112131415161718192021git clone https://gitee.com/swoole/swoole.gitcd swoolephpize// 预编译配置./configure \\--enable-coroutine \\--enable-openssl \\--enable-http2 \\--enable-async-redis \\--enable-sockets \\--enable-mysqlnd--with-php-config=/usr/local/php7/bin/php-config//安装make &amp;&amp; make installecho extension=swoole.so &gt;&gt;/usr/local/php7/lib/php.ini//查看swoole相关信息php --ri swoole Composer安装1234567891011121314wget https://mirrors.aliyun.com/composer/composer.pharcurl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composer &amp;&amp; chmod +x /usr/local/bin/composer//创建一个composer用户useradd composersu composercomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/","link":"/2020/06/20/php/centos-php-install/"},{"title":"PHP 获取文件的MimeType","text":"本地路径获取 远程链接获取 本地路径获取mime_content_type如果你的PHP版本是&lt; 5.3 的，可以直接使用 1echo mime_content_type(&quot;a.jpg&quot;); 该方法在PHP 5.3就废弃了，如果仍想使用此函数，那么可以对php进行配置启用magic_mime扩展。 Fileinfo函数在PHP 5.3及以上版本，官方推荐使用Fileinfo函数来获取mime-type，需要开启file_info扩展。 123$finfo = finfo_open(FILEINFO_MIME);$mimetype = finfo_file($finfo, $filename);finfo_close($finfo); image_type_to_mime_type(): 果需要判断MIME类型的文件只有图像文件，那么首先可以使用exif_imagetype()函数获取图像类型常量，再用image_type_to_mime_type()函数将图像类型常量转换成图片文件的MIME类型。 注意：需要在php.ini中配置打开php_mbstring.dll(Windows需要)和extension=php_exif.dll。 远程链接获取get_headers():123$strUrl = &quot;http://domian.com/demo.png&quot;;$arrTmp = get_headers($strUrl,true);$mime_type = $arrTmp['Content-Type']; CURL12345678910$strUrl = &quot;http://domian.com/demo.png&quot;;$ch = curl_init($strUrl);curl_setopt($ch,CURLOPT_HEADER,1);curl_setopt($ch,CURLOPT_NOBODY,1);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);$tmp = curl_exec($ch);//$mime_type = curl_getinfo($ch,CURLINFO_CONTENT_TYPE);curl_close($ch);preg_match('/Content-Type:\\s(.*)\\s/',$tmp,$arr);$mime_type = $arr[1];","link":"/2021/02/04/php/php-get-mimetype/"},{"title":"easyswoole实现websocket","text":"easyswoole实现websocket的步骤解析 配置 Websocket服务 1234567'MAIN_SERVER' =&gt; [ 'SERVER_TYPE' =&gt; EASYSWOOLE_WEB_SOCKET_SERVER, 'SETTING' =&gt; [ // 该参数项为心跳检测，严格参考swoole 配置说明 'heartbeat_check_interval' =&gt; 60, ],], fd与uuid绑定类App/Support/FdManager.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?phpnamespace App\\Support;use EasySwoole\\Component\\Singleton;use Swoole\\Table;/** * Class FdManager * @package App\\Support */class FdManager{ use Singleton; /** * @var Table */ private $fdUuid; /** * @var Table */ private $uuidFd; /** * FdManager constructor. * @param int $size */ public function __construct(int $size = 1024 * 256) { $this-&gt;fdUuid = new Table($size); $this-&gt;fdUuid-&gt;column('uuid', Table::TYPE_STRING, 25); $this-&gt;fdUuid-&gt;create(); $this-&gt;uuidFd = new Table($size); $this-&gt;uuidFd-&gt;column('fd', Table::TYPE_INT, 10); $this-&gt;uuidFd-&gt;create(); } /** * fd 绑定 * @param int $fd * @param string $uuid * @return mixed */ public function bind(int $fd, $uuid) { // TODO: Implement bind() method. $this-&gt;fdUuid-&gt;set($fd, ['uuid' =&gt; $uuid]); $this-&gt;uuidFd-&gt;set($uuid, ['fd' =&gt; $fd]); } /** * 删除fd绑定关系 * @param int $fd * @return mixed */ public function delete(int $fd) { // TODO: Implement delete() method. $uuid = $this-&gt;fdUuid($fd); if ($uuid) { $this-&gt;uuidFd-&gt;del($uuid); } $this-&gt;fdUuid-&gt;del($fd); } /** * 通过fd找到绑定的uuid * @param int $fd * @return mixed */ public function fdUuid(int $fd) { // TODO: Implement fdUuid() method. $ret = $this-&gt;fdUuid-&gt;get($fd); if ($ret) { return $ret['uuid']; } else { return null; } } /** * 通过uuid找到fd * @param $uuid * @return mixed */ public function uuidFd($uuid) { // TODO: Implement uuidFd() method. $ret = $this-&gt;uuidFd-&gt;get($uuid); if ($ret) { return $ret['fd']; } else { return null; } }} webscoekt 事件类/App/WebSocket/WebSocketEvent.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?phpnamespace App\\WebSocket;use App\\Support\\FdManager;/** * Class WebSocketEvent * @package App\\WebSocket */class WebSocketEvent{ /** * 握手事件 * 所有客户端建立连接时触发的方法 * @param \\swoole_http_request $request * @param \\swoole_http_response $response * @return bool */ public function onHandShake(\\swoole_http_request $request, \\swoole_http_response $response) { /** 此处自定义握手规则 返回 false 时中止握手 */ if (!$this-&gt;customHandShake($request, $response)) { $response-&gt;end(); return false; } /** 此处是 RFC规范中的WebSocket握手验证过程 必须执行 否则无法正确握手 */ if ($this-&gt;secWebsocketAccept($request, $response)) { $response-&gt;end(); return true; } $response-&gt;end(); return false; } /** * 关闭事件 * 所有客户端关闭时触发的方法 * @param \\swoole_server $server * @param int $fd * @param int $reactorId */ public function onClose(\\swoole_server $server, int $fd, int $reactorId) { /** @var array $info */ $info = $server-&gt;getClientInfo($fd); /** * 判断此fd 是否是一个有效的 websocket 连接 * 参见 https://wiki.swoole.com/wiki/page/490.html */ if ($info &amp;&amp; $info['websocket_status'] === WEBSOCKET_STATUS_FRAME) { /** * 判断连接是否是 server 主动关闭 * 参见 https://wiki.swoole.com/wiki/page/p-event/onClose.html */ if ($reactorId &lt; 0) { } //删除绑定关系 FdManager::getInstance()-&gt;delete($fd); } } /** * RFC规范中的WebSocket握手验证过程 * 以下内容必须强制使用 * * @param \\swoole_http_request $request * @param \\swoole_http_response $response * @return bool */ protected function secWebsocketAccept(\\swoole_http_request $request, \\swoole_http_response $response): bool { // ws rfc 规范中约定的验证过程 if (!isset($request-&gt;header['sec-websocket-key'])) { // 需要 Sec-WebSocket-Key 如果没有拒绝握手 return false; } if (0 === preg_match('#^[+/0-9A-Za-z]{21}[AQgw]==$#', $request-&gt;header['sec-websocket-key']) || 16 !== strlen(base64_decode($request-&gt;header['sec-websocket-key'])) ) { //不接受握手 return false; } $key = base64_encode(sha1($request-&gt;header['sec-websocket-key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true)); $headers = array( 'Upgrade' =&gt; 'websocket', 'Connection' =&gt; 'Upgrade', 'Sec-WebSocket-Accept' =&gt; $key, 'Sec-WebSocket-Version' =&gt; '13', 'KeepAlive' =&gt; 'off', ); if (isset($request-&gt;header['sec-websocket-protocol'])) { $headers['Sec-WebSocket-Protocol'] = $request-&gt;header['sec-websocket-protocol']; } // 发送验证后的header foreach ($headers as $key =&gt; $val) { $response-&gt;header($key, $val); } // 接受握手 还需要101状态码以切换状态 $response-&gt;status(101); // fd 和 uuid 进行绑定 FdManager::getInstance()-&gt;bind($request-&gt;fd, $request-&gt;get['uuid']); return true; } /** * 自定义握手事件 * @param \\swoole_http_request $request * @param \\swoole_http_response $response * @return bool */ private function customHandShake(\\swoole_http_request $request, \\swoole_http_response $response) { return true; }} Webcoket解析类App/WebSocket/WebSocketParser.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\WebSocket;use EasySwoole\\Socket\\AbstractInterface\\ParserInterface;use EasySwoole\\Socket\\Bean\\Caller;use EasySwoole\\Socket\\Bean\\Response;class WebSocketParser implements ParserInterface{ public function decode($raw, $client): ?Caller { // TODO: Implement decode() method. $caller = new Caller; if ($raw !== 'PING') { $payload = json_decode($raw, true); $class = isset($payload['controller']) ? $payload['controller'] : 'index'; $action = isset($payload['action']) ? $payload['action'] : 'actionNotFound'; $params = isset($payload['params']) ? (array)$payload['params'] : []; $controllerClass = &quot;\\\\App\\\\WebSocket\\\\Controller\\\\&quot; . ucfirst($class); if (!class_exists($controllerClass)) $controllerClass = &quot;\\\\App\\\\WebSocket\\\\Controller\\\\Index&quot;; $caller-&gt;setClient($caller); $caller-&gt;setControllerClass($controllerClass); $caller-&gt;setAction($action); $caller-&gt;setArgs($params); } else { // 设置心跳执行的类和方法 $caller-&gt;setControllerClass(\\App\\WebSocket\\Controller\\Base::class); $caller-&gt;setAction('heartbeat'); } return $caller; } public function encode(Response $response, $client): ?string { // TODO: Implement encode() method. return $response-&gt;getMessage(); }} 注册 websocket服务 EasySwooleEvent.php 1234567891011121314151617181920212223242526public static function mainServerCreate(EventRegister $register){ $conf = new \\EasySwoole\\Socket\\Config(); //设置Dispatcher为WebSocket 模式 $conf-&gt;setType(\\EasySwoole\\Socket\\Config::WEB_SOCKET); try { $conf-&gt;setParser(new \\App\\WebSocket\\WebSocketParser());//设置解析器对象 $dispatch = new \\EasySwoole\\Socket\\Dispatcher($conf);//创建Dispatcher对象并注入config对象 } catch (\\Exception $e) { Log::error($e-&gt;getMessage()); } //给server注册相关事件在WebSocket模式下onMessage事件必须注册 并且交给Dispatcher对象处理 $register-&gt;set(EventRegister::onMessage, function (\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) use ($dispatch) { $dispatch-&gt;dispatch($server, $frame-&gt;data, $frame); }); $websocketEvent = new \\App\\WebSocket\\WebSocketEvent(); //自定义握手事件 $register-&gt;set(EventRegister::onHandShake, function (\\swoole_http_request $request, \\swoole_http_response $response) use ($websocketEvent) { $websocketEvent-&gt;onHandShake($request, $response); }); //自定义关闭事件 $register-&gt;set(EventRegister::onClose, function (\\swoole_server $server, int $fd, int $reactorId) use ($websocketEvent) { $websocketEvent-&gt;onClose($server, $fd, $reactorId); });} 创建控制器目录，让easyswoole 的websocket服务像http服务那样调用方便 基类控制器App/WebSocket/Controller/Base.php 12345678910111213141516171819202122232425262728&lt;?phpnamespace App\\WebSocket\\Controller;use EasySwoole\\Socket\\AbstractInterface\\Controller;/** * Class Base * @package App\\WebSocket\\Controller */class Base extends Controller{ /** * 心跳执行的方法 * 该方法建议 迁移到 基类控制器 Base 中 * 推荐使用 easyswoole 自带的websocket客户端调试 * http://www.easyswoole.com/wstool.html */ public function heartbeat() { $this-&gt;response()-&gt;setMessage('心跳 heartbeat'); } /** * @param string|null $actionName */ protected function actionNotFound(?string $actionName) { $this-&gt;response()-&gt;setMessage($actionName . ' not find'); // 推送消息 }} 测试控制器App/WebSocket/Controller/Test.php 12345678910111213141516171819&lt;?phpnamespace App\\WebSocket\\Controller;class Test extends Base{ public function index() { $fd = $this-&gt;caller()-&gt;getClient()-&gt;getFd();// 请求用户的fd $data = $this-&gt;caller()-&gt;getArgs(); // 获取请求参数 // \\EasySwoole\\EasySwoole\\ServerManager::getInstance()-&gt;getSwooleServer()-&gt;worker_id //发送响应消息 $this-&gt;response()-&gt;setMessage(&quot;响应消息&quot;); $server = ServerManager::getInstance()-&gt;getSwooleServer(); //推送消息 $server-&gt;push($fd, “要推送的消息”); }}","link":"/2021/06/18/php/easyswoole-websockey/"},{"title":"think-swoole","text":"think-swoole实战案例演示 官网文档 thinkphp6文档https://www.kancloud.cn/manual/thinkphp6_0/1037479 swoole文档https://wiki.swoole.com/#/ think-swoole文档https://www.kancloud.cn/manual/thinkphp6_0/1359700 安装1composer require topthink/think-swoole 命令行1php think swoole [start|stop|reload|restart] 服务启动当你在命令行php think swoole下执行完成之后就会启动一个HTTP Server，可以直接访问当前的应用 123456789101112131415161718192021222324252627282930'server' =&gt; [ 'host' =&gt; env('SWOOLE_HOST', '0.0.0.0'), // 监听地址 'port' =&gt; env('SWOOLE_PORT', 9501), // 监听端口 'mode' =&gt; SWOOLE_PROCESS, // 运行模式 默认为SWOOLE_PROCESS 'sock_type' =&gt; SWOOLE_SOCK_TCP, // sock type 默认为SWOOLE_SOCK_TCP 'options' =&gt; [ // 服务启动后，进程ID存放文件 'pid_file' =&gt; runtime_path() . 'swoole.pid', // swoole 的日志文件 'log_file' =&gt; runtime_path() . 'swoole.log', // 守护进程模式设置 true 后台运行 'daemonize' =&gt; false, // 设置启动的reactor线程数 'reactor_num' =&gt; swoole_cpu_num(), // 设置启动的worker进程数 'worker_num' =&gt; swoole_cpu_num(), //配置Task进程的数量 'task_worker_num' =&gt; swoole_cpu_num(), //开启静态文件请求处理，需配合document_root 'enable_static_handler' =&gt; true, //静态文件根目录 'document_root' =&gt; root_path('public'), // 设置最大数据包尺寸，单位字节 'package_max_length' =&gt; 20 * 1024 * 1024, //配置发送输出缓冲区内存尺寸 'buffer_output_size' =&gt; 10 * 1024 * 1024, //设置客户端连接最大允许占用的内存数量 'socket_buffer_size' =&gt; 128 * 1024 * 1024, ],], 热更新swoole服务器运行过程中php文件是常驻内存运行，这样就可以避免重复的读取磁盘，重复的解释编译php，以便达到最高的性能，所以修改代码需要重启服务 think-swoole扩展提供热更新功能，在检测相关文件有更新会自动重启，不在需要手动完成重启，方便开发调试 生产环境下不建议开始文件监控，性能损耗，正常情况下你所修改的文件需要确认无误才能进行更新部署 .env里面设置APP_DEBUG = true会默认开启热更新 123456'hot_update' =&gt; [ 'enable' =&gt; env('APP_DEBUG', false), 'name' =&gt; ['*.php'], 'include' =&gt; [app_path()], 'exclude' =&gt; [],], 参数说明 参数 说明 enable 是否开启热更新 name 监听哪些类型的文件变动 include 监听哪些目录下的文件变动 exclude 排除目录 websocket先来一个官方的例子 123456789101112$server = new Swoole\\WebSocket\\Server(&quot;0.0.0.0&quot;, 9501);$server-&gt;on('open', function (Swoole\\WebSocket\\Server $server, $request) { echo &quot;server: handshake success with fd{$request-&gt;fd}\\n&quot;;});$server-&gt;on('message', function (Swoole\\WebSocket\\Server $server, $frame) { echo &quot;receive from {$frame-&gt;fd}:{$frame-&gt;data}\\n&quot;; $server-&gt;push($frame-&gt;fd, &quot;this is server&quot;);});$server-&gt;on('close', function ($ser, $fd) { echo &quot;client {$fd} closed\\n&quot;;});$server-&gt;start(); 开启think-swoole的websocket功能 \\config\\swoole.php 123'websocket' =&gt; [ 'enable' =&gt; true,], 创建三个事件 123php think make:listener SwWsConnectphp think make:listener SwWsClosephp think make:listener SwWsMessage 然后将这三个事件写到到事件监听中，分别有以下2中文件可以修改方式，注意二选一 thinkphp6自带的事件绑定app\\event.php 123456789101112131415 'listen' =&gt; [........ // 监听链接 'swoole.websocket.Connect' =&gt; [ \\app\\listener\\SwWsConnect::class ], //关闭连接 'swoole.websocket.Close' =&gt; [ \\app\\listener\\SwWsClose::class ], //发送消息场景 'swoole.websocket.Message' =&gt; [ \\app\\listener\\SwWsMessage::class ] ], think-swoole事件绑定config\\swoole.php 12345'listen' =&gt; [ 'connect'=&gt;\\app\\listener\\SwWsConnect::class, 'close'=&gt;\\app\\listener\\SwWsClose::class, 'message'=&gt; \\app\\listener\\SwWsMessage::class], 怎么选择是保存在config\\swoole.php还是app\\event.php配置中呢？ 首先我们 我们确定一下我们这个项目中存在有几个实时通讯， 如果只是存在一个实时通讯 个人建议 保存在config\\swoole.php 如果是存在多个实时通讯，就保存在app\\event.php key值 必须是swoole.websocket.事件名称 例如 swoole.websocket.Message 开始写事件中中方法 连接事件app\\listener\\SwWsConnect.php 123456public function handle($event, \\think\\swoole\\websocket $ws){ // 获取当前发送者的fd $fd = $ws-&gt;getSender(); echo &quot;server: handshake success with fd{$fd}\\n&quot;;} 关闭事件app\\listener\\SwWsClose.php 123456public function handle($event, \\think\\swoole\\websocket $ws){ $fd = $ws-&gt;getSender(); echo &quot;client {$fd} closed\\n&quot;;} message事件app\\listener\\SwWsMessage.php 1234567public function handle($event, \\think\\swoole\\websocket $ws){ $fd = $ws-&gt;getSender(); $data = json_encode($event); echo &quot;receive from {$fd}:{$data}\\n&quot;; $ws-&gt;emit(&quot;this is server&quot;, $fd);} 启动php think swoole进行测试 think-swoole中的websocket方法总结 12345678910//给自己发消息$ws-&gt;emit(&quot;this is server&quot;, $ws-&gt;getSender());//给指定一个fd发消息$ws-&gt;to($to)-&gt;emit(&quot;messagecallback&quot;,$data);//给指定多个人发消息$ws-&gt;to([1,2,3])-&gt;emit(&quot;messagecallback&quot;,$data);//发送给所有的(不包含自己)$ws-&gt;broadcast()-&gt;emit(&quot;messagecallback&quot;,$data);//模拟formfd 给tofd 发送消息$ws-&gt;setSender($formfd)-&gt;to($tofd)-&gt;emit(&quot;messagecallback&quot;,$data); 注意：在多个实时通讯场景下使用 emit 第一个参数传入 传入 事件名称callback 例如 messagecallback 如果你发现你think-swoole中有些没有swoole中的方法可以这么干 123456$sw = app('swoole.server');$sw = app(&quot;think\\swoole\\Manager&quot;)-&gt;getServer();//以上二选一$es = $sw-&gt;isEstablished($fd); //检查连接是否为有效的WebSocket客户端连接var_dump($es); 聊天室room实现前端文件参考 html\\room.html 或 html\\room-socket-io.html 123php think make:listener SwRoomJoinphp think make:listener SwRoomLeavephp think make:listener SwRoomMessage 事件绑定 123456789101112// 加入房间'swoole.websocket.RoomJoin' =&gt; [ \\app\\listener\\SwRoomJoin::class],// 离开房间'swoole.websocket.Roomleave' =&gt; [ \\app\\listener\\SwRoomLeave::class],// 在房间发消息'swoole.websocket.RoomMessage' =&gt; [ \\app\\listener\\SwRoomMessage::class] 加入房间逻辑 12345678910111213141516public function handle($event, \\think\\swoole\\websocket $ws, \\think\\swoole\\websocket\\room $room){ $fd = $ws-&gt;getSender(); //客户端假如定的room $roomid = $event['room']; //获取指定房间下有哪些客户端 $roomfds = $room-&gt;getClients($roomid); // 判断这个房间有没有自己 如果有自己就不需要再次发送通知 if (in_array($fd, $roomfds)) { $ws-&gt;to($roomfds)-&gt;emit(&quot;roomjoincallback&quot;, &quot;房间{$roomid}已加入&quot;); return; } //加入房间 $ws-&gt;join($roomid); $ws-&gt;to($roomfds)-&gt;emit(&quot;roomjoincallback&quot;, &quot;{$fd}加入房间{$roomid}成功&quot;);} 离开房间逻辑 123456789101112131415public function handle($event, \\think\\swoole\\websocket $ws, \\think\\swoole\\websocket\\Room $room){ $roomid = $event['room']; $fd = $ws-&gt;getSender(); $roomfds = $room-&gt;getClients($roomid); if (!in_array($fd, $roomfds)) { $ws-&gt;emit(&quot;roomleavecallback&quot;, &quot;{$fd}不在{$roomid}房间内，怎么离开~&quot;); return; } //离开房间 $ws-&gt;leave($roomid); //获取当前客户端加入了哪些客户端 $rooms = $room-&gt;getRooms($fd); $ws-&gt;to($roomfds)-&gt;emit(&quot;roomleavecallback&quot;, &quot;{$fd}已离开了~~&quot;);} 在房间发布聊天逻辑 12345678910111213public function handle($event, \\think\\swoole\\websocket $ws, \\think\\swoole\\websocket\\room $room){ // $roomid = $event['room']; $text = $event['text']; $fd = $ws-&gt;getSender(); $roomfds = $room-&gt;getClients($roomid); if (!in_array($fd, $roomfds)) { $ws-&gt;emit(&quot;roommessagecallback&quot;, &quot;{$fd}不在{$roomid}房间内，无法进入发布聊天~&quot;); return; } $ws-&gt;to($roomfds)-&gt;emit(&quot;roommessagecallback&quot;, $text);} 事件订阅1php think make:listener SwSubscribe app\\listener\\SwSubscribe.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpdeclare (strict_types = 1);namespace app\\listener;class SwSubscribe{ protected $ws = null; // public function __construct() // { // $this-&gt;ws = app('think\\swoole\\Websocket'); // } public function __construct(\\think\\Container $c) { $this-&gt;ws = $c-&gt;make(\\think\\swoole\\Websocket::class); } public function onConnect() { $fd = $this-&gt;ws-&gt;getSender(); echo &quot;server: handshake success with fd{$fd}\\n&quot;; } public function onClose() { $fd = $this-&gt;ws-&gt;getSender(); echo &quot;client {$fd} closed\\n&quot;; } public function onMessage($event) { $fd = $this-&gt;ws-&gt;getSender(); var_dump($event); echo &quot;server: handshake success with fd{$fd}\\n&quot;; $this-&gt;ws-&gt;emit(&quot;this is server&quot;, $fd); }} 有点类似 将原生的swoole代码改成面向对象代码，生效方法 config\\swoole.php中在subscribe 加入\\app\\listener\\SwSubscribe::class 123'subscribe' =&gt; [ \\app\\listener\\SwSubscribe::class], 在app\\event.php文件中的 swoole.websocket.Connect 相当于 app\\listener\\SwSubscribe.php文件中的onConnect函数。如果同时存在的存在的话，就会向客户端发送2次以上的消息 Task任务投递https://wiki.swoole.com/#/start/start_task 生成事件 1php think make:listener SwSendEmailTask 编写发送邮件方法app\\listener\\SwSendEmailTask.php 12345678public function handle($event){ var_dump($event); // echo &quot;开发发送邮件&quot;.time(); sleep(3); echo &quot;结束发送邮件&quot;.time();} 注册事件app\\event.php 123'swoole.task'=&gt;[ \\app\\listener\\SwSendEmailTask::class], 在控制器中投递任务 123456789101112131415161718public function doRegister(){ $server = app('swoole.server'); $server-&gt;task(\\app\\listener\\SwSendEmailTask::class); return &quot;注册成功&quot;;}public function doRegister(\\think\\swoole\\Manager $manager){ $server = $manager-&gt;getServer(); $server-&gt;task(\\app\\listener\\SwSendEmailTask::class); return &quot;注册成功&quot;;}public function doRegister(\\Swoole\\Server $server){ $server-&gt;task(\\app\\listener\\SwSendEmailTask::class); return &quot;注册成功&quot;;} 三种获取\\Swoole\\Server,任意选其一 在swoole中还有一个事件叫finish，它的作用就是把异步任务的结果返回，在think-swool是这么处理的 定义一个发送邮件异步任务处理结果的事件 1php think make:listener SwSendEmailFinish 注册事件app\\event.php 123'swoole.finish'=&gt;[ \\app\\listener\\SwSendEmailFinish::class], 在task任务中调用 123456789public function handle($event){ var_dump($event); // echo &quot;开发发送邮件&quot;.time(); sleep(3); echo &quot;结束发送邮件&quot;.time(); $event-&gt;finish(\\app\\listener\\SwSendEmailFinish::class);} 高性能共享内存 Tablehttps://wiki.swoole.com/#/memory/table 先定结构在进行操作数据（原生swoole操作） 1234567891011121314151617181920212223242526$table = new Swoole\\Table(1024);//创建表$table-&gt;column(&quot;id&quot;, Swoole\\Table::TYPE_INT);$table-&gt;column(&quot;name&quot;, Swoole\\Table::TYPE_STRING);$table-&gt;column(&quot;money&quot;, Swoole\\Table::TYPE_FLOAT);$table-&gt;create();//添加数据$table-&gt;set(&quot;zq&quot;, [ 'id' =&gt; 1, 'name' =&gt; &quot;zhiqiang&quot;, 'money' =&gt; 100,]);//获取一行数据$table-&gt;get(&quot;zq&quot;);// 修改数据// 字段递增$table-&gt;incr(&quot;zq&quot;,&quot;money&quot;,2);//递减$table-&gt;decr(&quot;zq&quot;,&quot;money&quot;,2);// 返回 table 中存在的条目数。$table-&gt;count();//遍历table中的数据foreach($table as $item){ var_dump($item);} think-swoole中的操作 先对table表结构进行初始化config\\swoole.php 123456789101112131415161718192021'tables' =&gt; [ 'user'=&gt;[ 'size'=&gt;1024, 'columns'=&gt;[ [ 'name'=&gt;'id', 'type'=&gt;\\Swoole\\Table::TYPE_INT ], [ 'name'=&gt;'name', 'type'=&gt;\\Swoole\\Table::TYPE_STRING, 'size'=&gt;32 ], [ 'name'=&gt;'money', 'type'=&gt;\\Swoole\\Table::TYPE_FLOAT ], ], ],], 操作数据 1234567891011121314151617181920212223$table = app('swoole.table.user');$table-&gt;set(&quot;zq&quot;, [ 'id' =&gt; 1, 'name' =&gt; &quot;zhiqiang&quot;, 'money' =&gt; 100]);//获取一行数据$table-&gt;get(&quot;zq&quot;);// 修改数据// 字段递增$table-&gt;incr(&quot;zq&quot;, &quot;money&quot;, 2);//递减$table-&gt;decr(&quot;zq&quot;, &quot;money&quot;, 2);// 返回 table 中存在的条目数。$table-&gt;count();//遍历table中的数据foreach ($table as $item) {var_dump($item);}// 检查 table 中是否存在某一个 key。$table-&gt;exist('zq');//获取实际占用内存尺寸,单位字节$table-&gt;momorySize(); RPCRPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。 详细介绍：https://developer.51cto.com/art/201906/597963.htm 解决分布式系统中，服务之间的调用问题。 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。 节点角色说明： Server: 暴露服务的服务提供方 Client: 调用远程服务的服务消费方 Registry: 服务注册与发现的注册中心 think-swoole实现RPC功能 服务器端接口定义app/rpc/interfaces/UserInterface.php1234567&lt;?phpnamespace app\\rpc\\interfaces;interface UserInterface{ public function create(); public function find(int $id);} 实现接口app/rpc/services/UserService.php12345678910111213141516&lt;?phpnamespace app\\rpc\\services;use app\\rpc\\interfaces\\UserInterface;class UserService implements UserInterface{ public function create() { // TODO: Implement create() method. return &quot;service create success&quot;; } public function find(int $id) { // TODO: Implement find() method. return $id. &quot;查询数据遍历&quot;; }} 注册rpc服务config/swoole.php123456789101112131415'rpc' =&gt; [ 'server' =&gt; [ //开启rpc服务 'enable' =&gt; true, //rpc端口 'port' =&gt; 9000, 'services' =&gt; [ //注册服务 \\app\\rpc\\services\\UserService::class ], ], // 如果填写也是可以调用其他服务端 'client' =&gt; [ ],], 启动服务端 1php think swoole start / php think swoole:rpc 客户端12345678910111213'rpc' =&gt; [ 'server' =&gt; [ ], 'client' =&gt; [ 'tp6'=&gt;[ //服务端的ip地址 'host'=&gt;'127.0.0.1', //服务端对应的端口 'port'=&gt;'9000' ] // 更多服务端 ],], 运行php think rpc:interface生成RPC接口文件app\\rpc.php 123456789101112&lt;?php/** * This file is auto-generated. */declare(strict_types=1);namespace rpc\\contract\\tp6;interface UserInterface{ public function create(); public function find(int $id);}return ['tp6' =&gt; ['rpc\\contract\\tp6\\UserInterface']]; 在控制器调用 123456 public function index(\\rpc\\contract\\tp6\\UserInterface $user) { // $user-&gt;find(1);// $user-&gt;create(); } 定时任务在think-swoole 2.0版本的时候还是支持自定义定时任务配置,详细参考https://github.com/top-think/think-swoole/tree/2.0 在3.0就不支持了，在这里介绍一个通用的命令行启动定时任务 1php think make:command SwooleTimer 加载命令行config/console.php 1234'commands' =&gt; [ 'swooletimer'=&gt;app\\command\\SwooleTimer::class ...........], 书写命令脚本app/command/SwooleTimer.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpdeclare (strict_types = 1);namespace app\\command;use think\\console\\Command;use think\\console\\input\\Argument;class SwooleTimer extends Command{ protected function configure() { // 指令配置 $this-&gt;setName('app\\command\\swooletimer') -&gt;addArgument('action', Argument::OPTIONAL, &quot;start | stop&quot;, 'start') -&gt;setDescription('Swoole Timer for ThinkPHP'); } public function handle() { $action = $this-&gt;input-&gt;getArgument('action'); if (in_array($action, ['start','stopall'])) { $this-&gt;app-&gt;invokeMethod([$this, $action], [], true); } else { $this-&gt;output-&gt;writeln(&quot;&lt;error&gt;Invalid argument action:{$action}, Expected start&lt;/error&gt;&quot;); } } /** * 启动定时任务 主要任务计划在这里书写 */ protected function start() { // https://wiki.swoole.com/#/timer $timer_id=swoole_timer_tick(2000,function (){ echo &quot;2s循环执行需要做的事情&quot;.time().&quot;\\n&quot;; }); $this-&gt;output-&gt;writeln(&quot;Swoole Timer_id:{$timer_id} &quot;); } /** * 清除所有的定时任务 */ protected function stop(){ swoole_timer_clear_all(); $this-&gt;output-&gt;writeln(&quot;Swoole Timer clear all ok&quot;); }}","link":"/2020/06/04/php/think-swoole/"},{"title":"xdebug+webgrind对php5.6做性能分析环境搭建","text":"python3环境搭建xdebug扩展安装 python3安装123456wget https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tar.xzmkdir -p /usr/local/code/python3tar -xvf Python-3.7.7.tar.xz -C /usr/local/codecd /usr/local/code/Python-3.7.7/ &amp;&amp; ./configure prefix=/usr/local/python3make &amp;&amp; make installln -s /usr/local/python3/bin/python3 /usr/bin/python3 dot命令安装1yum -y install graphviz xdebug安装 https://xdebug.org/docs/install 12345678910111213pecl install xdebugmkdir -p /tmp/xdebugchown -R www:www /tmp/xdebug///修改php.inizend_extension=xdebug.so[xdebug]xdebug.profiler_append=0xdebug.profiler_output_name=&quot;cachegrind.out.%R%u&quot;xdebug.profiler_enable=Onxdebug.profiler_output_dir=&quot;/tmp/xdebug/&quot;xdebug.profiler_enable_trigger=On webgrind可视化界面12345git clone https://github.com/jokkedk/webgrind.git//修改config.php修改成static $storageDir = '/tmp/xdebug/';static $profilerDir = '/tmp/xdebug/';","link":"/2020/06/27/php/xdebug-webgrind/"},{"title":"thinkphp+mysql无线分类从需求到代码演示","text":"栏目无线分类 无线分销（技术是无罪的，商业请使用三级分销） 省市县联动 在我们做任何系统中离不开无线分类这个分类，同样也是老掉牙的问题。为什么又拿来说呢？归功到底还是博客的内容太少。 应用场景 栏目无线分类 无线分销（技术是无罪的，商业请使用三级分销） 省市县联动 需求决定代码无论你做任何系统都是有需求，你才去研究；没有需求，就是伪需求，自己玩玩就好。无论什么样的 需求都离不开sql和逻辑判断，下面的需求主要是围绕thinkphp+mysql来实现案例 表结构 字段 类型 NULL 默认 注释 id int(10) 否 自增ID parent_id int(10) 否 0 上级ID name varchar(50) 否 名称 order int(10) 否 0 排序 根据子类ID获取所有父类12345678function get_user_father_array($uid,$array=[]){ $user = \\think\\Db::name('users')-&gt;where('id',$uid)-&gt;find(); $array[] = $user; if($user['parent_id']){ return get_user_father_array($user['parent_id'],$array); } return $array;} 根据父类查所有子类1234567// sql 获取子类数据function get_child_user_sql($uid){ $sql = &quot;SELECT * FROM &quot;. &quot;(SELECT id,parent_id FROM users ORDER BY parent_id,id) as t,(SELECT @pv := {$uid}) as pv &quot;. &quot;WHERE find_in_set(parent_id, @pv) AND LENGTH(@pv := concat(@pv, ',', id))&quot;; return \\think\\Db::query($sql);} 点对点是否在一个枝干上 XYZ的上级为0，也就是说是顶级树干 X 推荐了 B 和 C B 推荐XB1、XB2、XB3、…..XBn C 推荐XC1、XC2、XC3、……XCn 问： XB1和XC1 和是否在一枝干上 答：某个项目告诉我不是，为什么？ XB1的分枝干包含 X、B XC1的分枝干包含 X、C 不难看出来 他们的上级是不同的，所有不是，所以我们要实现这个需求，就是通过路径来判断 实现步骤 先找到XB1的所有父类连接成字符串 然后找到XC1的所有父类连接成字符串 比较2个字符串是否包含或被包含 代码实现一下 123456789101112131415161718192021$left = array_column(get_user_father_array($left_uid),'id');$leftstr = implode(&quot;,&quot;,$left);$right = array_column(get_user_father_array(right_uid),'id');$rightstr = implode(&quot;,&quot;,$right);function str2strpos($str1 ,$str2){ $str1len = strlen($str1); $str2len = strlen($str2); if($str1len &gt; $str2len &amp;&amp; strpos($str1,$str2) !== false){ return true; } if($str1len &lt; $str2len &amp;&amp; strpos($str2,$str1) !== false){ return true; } return false;}if(str2strpos($leftstr,$rightstr)){ echo &quot;在同一枝干上&quot;}","link":"/2020/06/28/php/thinkphp-mysql-tree/"},{"title":"压测AB以及监控工具详解","text":"ab命令参数 查看cpu和内存使用率top iostat 查看硬盘带宽命令 客户端压测工具AB1ab(选项)(参数) 地址 -A：指定连接服务器的基本的认证凭据；-c：指定一次向服务器发出请求数；-C：添加cookie；-g：将测试结果输出为“gnuolot”文件；-h：显示帮助信息；-H：为请求追加一个额外的头；-i：使用“head”请求方式；-k：激活HTTP中的“keepAlive”特性；-n：指定测试会话使用的请求数；-p：指定包含数据的文件；-q：不显示进度百分比；-T：使用POST数据时，设置内容类型头；-v：设置详细模式等级；-w：以HTML表格方式打印结果；-x：以表格方式输出时，设置表格的属性；-X：使用指定的代理服务器发送请求；-y：以表格方式输出时，设置表格属性。 1ab -c 200 -n 200 http://127.0.0.1:3000/ 运行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445This is ApacheBench, Version 2.3 &lt;$Revision: 1748469 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 127.0.0.1 (be patient)Completed 100 requestsCompleted 200 requestsFinished 200 requestsServer Software:Server Hostname: 127.0.0.1 #域名Server Port: 3000 #请求端口号Document Path: / #文件路径Document Length: 11 bytes #页面字节数Concurrency Level: 200 #请求的并发数Time taken for tests: 0.192 seconds #总访问时间Complete requests: 200 #请求成功数量Failed requests: 0 #请求失败数量Total transferred: 29400 bytes #请求总数据大小（包括header头信息）HTML transferred: 2200 bytes #html页面实际总字节数Requests per second: 1041.68 [#/sec] (mean) #每秒多少请求Time per request: 191.998 [ms] (mean) #用户平均请求等待时间 Time per request: 0.960 [ms] (mean, across all concurrent requests) # 服务器平均处理时间Transfer rate: 149.54 [Kbytes/sec] received #每秒获取的数据长度Connection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 1Processing: 9 94 49.2 95 179Waiting: 3 90 51.0 91 178Total: 9 95 49.2 95 179Percentage of the requests served within a certain time (ms) 50% 95 #50%用户请求在95ms内返回 66% 122 #66%用户请求在122ms内返回 75% 138 #75%用户请求在138ms内返回 80% 146 #80%用户请求在146ms内返回 90% 163 #90%用户请求在163ms内返回 95% 171 #95%用户请求在171ms内返回 98% 176 #98%用户请求在176ms内返回 99% 178 #99%用户请求在178ms内返回 100% 179 (longest request) Requests per second: 1041.68 [#/sec] (mean) （吞吐率，简称QPS）每秒服务器承载请求量是多少，以上测试数据表示每秒可以处理 1041.68并发量，也就是说有 1100个用户去访问这个服务器，这个服务器是可以抗的住Time per request: 191.998 [ms] (mean) 每次请求花费多少毫秒Time per request: 0.960 [ms] (mean, across all concurrent requests)并发情况下，0.960毫秒得到结果Transfer rate: 149.54 [Kbytes/sec] received(吞吐量) 每秒这个服务器吞/吐的数据量是多少 性能分析工具Node自带 profile1node --prof index.js php分析工具xdebug+webgrind12pecl install xdebughttps://github.com/jokkedk/webgrind.git php分析工具 xhprof12http://pecl.php.net/package/xhprofhttps://github.com/tideways/php-xhprof-extension 服务端监控客户端服务端也需要开启监控，检测具体问题所在 查看cpu和内存使用率123456789[root@VM_0_4_centos ~]# toptop - 01:19:19 up 6 days, 9 min, 1 user, load average: 0.00, 0.01, 0.05Tasks: 122 total, 1 running, 121 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.2 us, 0.2 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 3880224 total, 235108 free, 973224 used, 2671892 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 2615988 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43692 3692 2288 S 0.0 0.1 0:32.31 systemd 第一行：概况 当前时间 01:19:19； 从本次开机到现在经过的时间 up 6 days,9 min； 当前有几个用户登录到该机器。1 user ； 系统1分钟、5分钟、15分钟内的平均负载值load average: 0.00, 0.01, 0.05 第二行：进程计数（Tasks） 进程总数122 total； 正在运行的进程数1 running； 睡眠的进程数121 sleeping； 停止的进程数0 stopped； 僵尸进程数0 zombie 第三行：CPU使用率（%Cpu(s)） 进程在用户空间（user）消耗的CPU时间占比，不包含调整过优先级的进程。%Cpu(s): 0.2 us 进程在内核空间（system）消耗的CPU时间占比。0.2 sy 调整过用户态优先级的（niced）进程的CPU时间占比。0.0 ni 空闲的（idle）CPU时间占比。99.7 id 等待（wait）I/O完成的CPU时间占比。0.0 wa 处理硬中断（hardware interrupt）的CPU时间占比。0.0 hi 处理软中断（software interrupt）的CPU时间占比。0.0 si 当Linux系统是在虚拟机中运行时，等待CPU资源的时间（steal time）占比。0.0 st 第四、五行：物理内存和交换空间（Mem/Swap） 内存总量。3880224 total 空闲内存量。235108 free 使用中的内存量。973224 used 缓存和page cache占用的内存量。2671892 buff/cache 接下来就是进程详细信息 PID进程ID USER进程所有者的用户名。 PR从系统内核角度看的进程调度优先级。 NI进程的nice值，即从用户空间角度看的进程优先级。值越低，优先级越高。 VIRT进程申请使用的虚拟内存量。 RES进程使用的驻留内存（即未被swap out的内存）量。 SHR进程使用的共享内存量。 S进程状态。R=running，S=interruptible sleeping，D=uninterruptible sleeping，T=stopped，Z=zombie。 %CPU进程在一个更新周期内占用的CPU时间比例。 %MEM进程占用的物理内存比例。 TIME+进程创建后至今占用的CPU时间长度。 COMMAND运行进程使用的命令。 iostat 查看硬盘带宽命令1234567891011[root@VM_0_4_centos ~]# yum install -y sysstat[root@VM_0_4_centos ~]# iostatLinux 3.10.0-1062.18.1.el7.x86_64 (VM_0_4_centos) 06/27/2020 _x86_64_ (2 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.35 0.00 0.20 0.09 0.00 99.35 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 3.10 3.39 22.73 1758510 11783276vdb 1.69 5.79 14.56 3001589 7547888scd0 0.00 0.00 0.00 910 0 %user：CPU处在用户模式下的时间百分比。 %nice：CPU处在带NICE值的用户模式下的时间百分比。 %system：CPU处在系统模式下的时间百分比。 %iowait：CPU等待输入输出完成时间的百分比。 %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。 %idle：CPU空闲时间百分比。 tps：该设备每秒的传输次数 kB_read/s：每秒从设备（drive expressed）读取的数据量； kB_wrtn/s：每秒向设备（drive expressed）写入的数据量； kB_read： 读取的总数据量； kB_wrtn：写入的总数量数据量； 注意： 如果%iowait的值过高，表示硬盘存在I/O瓶颈 如果%idle值高，表示CPU较空闲 如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。 如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。 常见命令 1234567891011121314# 每隔2秒刷新显示，且显示3次iostat 2 3# 显示指定磁盘信息iostat -d /dev/vdb1# 显示tty和cpu信息iostat -t# 以M为单位显示所有信息iostat -m# 查看设备使用率（%util）、响应时间（await）iostat -d -x -k 1 1","link":"/2020/06/27/tool/pressure-test/"},{"title":"Rsync文件同步工具介绍","text":"Rsync介绍 Rsync介绍 是一款开源的、快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具。软件适用于unix、linux、windows等多种操作系统平台。全称为Remote Rynchronization。ssh带的scp,但优于scp命令的功能，scp每次都是全量拷贝，而rsync可以增量拷贝。Rsync还可以在本地主机的不同分区或目录之间全量及增量的复制数据，类型cp命令。Rsync还可以实现删除文件和目录的功能。一个rsync相当于scp,cp,rm，但是还优于他们每一个命令。 Rsync同步 在同步备份数据时，默认情况下，Rsync通过其独特的“quick check”算法，它仅同步大小或者最后修改时间发生变化的文件或目录。也可以根据权限，属主等属性的变化同步，但需要制定相应的参数，甚至可以实现只同步一个文件里有变化的内容部分，所以能实现快速的同步备份数据。版本区别：version2版本会把要同步的文件加载和已有的文件比较，如果发生变化就同步过去。version3版本边比较边同步。Rsync是文件系统之上，基于文件的同步；基于block的同步用drbd。union双机互相同步，csync2多机同步。 Rsync特性 支持拷贝特殊文件如链接文件、设备等。 可以有排除指定文件或目录同步的功能，相当于打包命令tar的排除功能。 可以做到保持源文件或目录的权限、时间、软硬链接、属主、组等所有属性均不改变-P。 可以实现增量同步，既只同步发生变化的数据，因此数据传输效率高。 可以使用rcp、rsh、ssh等方式来配合传输文件（rsync本身不对数据加密） 可以通过socket（进程方式）传输文件和数据。（服务端与客户端） 支持匿名的或认证（无需系统用户）的进程模式传输，可实现方便安全的进行数据备份及镜像。 Rsync企业应用 两台服务器之间的数据同步 集群服务器的数据同步 定时同步（cron+rsync）与实时同步（rsync+inotify、rsync+sersync） Rsync工作方式 单个主机本地之间的数据传输（此时类似于cp命令的功能） 借助rcp、ssh等通道来传输数据（此时类似于scp命令的功能） 以守护进程（socket）的方式传输数据（这个是rsync自身的重要功能） Rsync优缺点 优点：增量备份同步、支持socket（daemon）、集中备份 缺点：大量小文件同步的时候比对时间较长，有的时候rsync进程会停止。解决方式可以打包同步或者通过drbd方式。同步大文件（10G）这样的大文件有时候也会有问题。（发生同步中断）未完成同步前，是隐藏文件。 常用参数12345678910111213141516171819语法： rsync [option...] src... [dest]说明：[option]为同步时的参数选项 -avz-z --compress 传输时进行压缩以提高传输效率，--compress-level=NUM可按级别压缩。-v --verbose 详细模式输出，传输时的进度等信息。-a --archive归档模式，表示以递归方式传输文件，并保持所有文件属性。等于-rtopgDl-r --对子目录以递归模式，及目录下的所有目录都同样传输。-t --保持文件时间信息。-o --保持文件属主信息。-p --保持文件权限。-g --保持文件属组信息。-P --显示同步的过程及传输时的进度信息。-D --保持设备文件信息。-l --保留软连接。-e 使用的信道协议，指定替代rsh的shell。--exclude=PATTERN 指定排除不需要传输的文件模式。[src]为源，即需要拷贝的分区、文件或目录等。[dest]为目的分区、文件或目录等。 常见使用方法单个主机本地之间的数据传输 本地传输模式（local-only mode） 1rsync -az /home/e-books/ /home/books/ 将远程目录复制/同步到本地计算机 1rsync -avzh root@192.168.1.100:/www/rsync/php7 /home/php7/ 将文件和目录复制/同步到服务器或从服务器同步 1234rsync -avz /home/rsync/ root@192.168.0.101:/www/rsync///带进度条rsync -avz ssh --progress /home/rsync/ root@192.168.0.101:/www/rsync/","link":"/2020/06/09/tool/rsync/"},{"title":"windwos10查看wifi密码","text":"12345C:\\Users\\admin&gt;netsh// 检查自己连接过的WiFinetsh&gt;wlan show profile// 查看指定wifi信息netsh&gt;wlan show profile WiFi名称 key=clear","link":"/2021/01/30/windwos/windwos10-cmd-wifi-info/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"solr","slug":"solr","link":"/tags/solr/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysql索引类型","slug":"mysql索引类型","link":"/tags/mysql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/"},{"name":"node-sequelize","slug":"node-sequelize","link":"/tags/node-sequelize/"},{"name":"swoole","slug":"swoole","link":"/tags/swoole/"},{"name":"easyswoole","slug":"easyswoole","link":"/tags/easyswoole/"},{"name":"think-swoole","slug":"think-swoole","link":"/tags/think-swoole/"},{"name":"thinkphp","slug":"thinkphp","link":"/tags/thinkphp/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"项目管理","slug":"项目管理","link":"/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"网络编程","slug":"网络编程","link":"/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"windwos","slug":"windwos","link":"/categories/windwos/"}]}